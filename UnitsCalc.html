<!--
  Copyright 2021 Stan Switzer

    This work is licensed under a Creative Commons Attribution-ShareAlike
    4.0 International License. https://creativecommons.org/licenses/by-sa/4.0/

  Synopsis:

    A calculator originaly designed to do inconvenient math with expressions in
    feet and inches such as dividing 5' 6 3/8" by 3. Hence, its grammar supports
    these conventional notations and favors the display of feet and inches
    results when applicable. But it now supports fairly general dimensional calculations
    in units of length, mass, time, information, temperature, electrical current, etc.

    If the final component of the file/URL contains "inch", it will display the original
    user interface, otherwise the interface will be simplified.
-->
<html>
  <head>
    <title>Units Calculator</title>
    <base target="_blank"> <!-- all links open in a new tab/page -->
    <style type="text/css">
      body {
        padding: 4px 12px;
        box-sizing: border-box;
        margin: 0px 8px;
        font-family: caption, sans-serif;
        font-size: 110%;
        background-color: #f8f8f8;
      }

      @media (hover: none) {
        body {
          font-size: 125%;
        }
      }

      body:not([data-presentation-mode="legacy"]) .legacy {
        display: none;
      }

      body:not([data-presentation-mode="legacy"]) > .layout-column {
        width: 35em;
      }

      body:not([data-protocol="file:"]) .local-only {
        display: none;
      }

      /* Spiff up input fields */
      input[type="text"] {
        font-size: 110%;
        border-radius: 5px;
        padding: 1px 4px;
      }

      @media (hover: none) {
        input[type="text"] {
          font-size: 150% !important;
        }
      }

      /*
       * Layout containers
       */
      div.layout-column {
        display: flex;
        flex-flow: column nowrap;
      }
      div.layout-column > div {
        margin: 4px 0px;
      }
      div.layout-column {
        height: 100%;
      }
      div.layout-row {
        display: flex;
        flex-flow: row nowrap;
        flex: 0 0 auto;
      }
      div.expands {
        /* https://geon.github.io/programming/2016/02/24/flexbox-full-page-web-app-layout */
        flex: 1 1 auto;
        overflow: hidden;
      }
      div.shrink-wrap {
        width: min-content;
      }
      div.force-width {
        width: max-content;
      }

      /*
       * Initially-hidden help content.
       * Help contains a <span class="close-button"> for a close button
       * and a <div> for help content which is made scrollable.
       */
      div.help {
        padding: 0px 4px 0px 20px;
        background-color: #e8e8e8;
        position: absolute;
        display: none;
        top: 10%;
        left: 25%;
        right: 16px;
        bottom: 16px;
        border: 2px solid black;
      }
      div.help > span.close-button {
        color: #888888;
        font-weight: bold;
        font-size: 250%;
        float: right;
        cursor: pointer;
        transition: 0.3s;
      }
      div.help > span.close-button:before {
        content: "\d7"; /* Unicode times character */
      }
      div.help > span.close-button:hover {
        transform: scale(1.25);
        color: black;
      }
      div.help > span.close-button:active {
        transform: scale(1.5);
      }
      div.help > div {
        overflow-y: auto;
        height: 100%;
      }
      /* styling for help content */
      div.help td, div.help th {
        padding: 0em .15em;
        vertical-align: top;
        text-align: left;
      }
      div.help ul {
        padding-left: 1.25em;
      }
      div.help ul > li {
        margin: .5em;
      }
      div.help code {
        font-weight: bolder;
        font-family: caption, sans-serif;
      } 
      div.help code.abstract {
        font-style: italic;
      }
      div.help table.example tr td:first-child {
        width: 7em;
      }
      div.help table.example2 tr td:nth-child(1),
      div.help table.example2 tr td:nth-child(2) {
        width: 3em;
      }
      div.help table.example, div.help table.example2 {
        margin-left: 1em;
      }
      /* Testing affordance; example text can be stuffed into the expr box */
      div.help code:hover,
      div.help table.stuff.example tr td:first-child:hover,
      div.help table.stuff.example2 tr td:nth-child(1):hover,
      div.help table.stuff.example2 tr td:nth-child(2):hover {
        cursor: pointer;
        color: #0000dd;
        text-decoration: underline;
        --click-action: stuff-text
      }

      /*
       * Makes a <span> into a "button"
       */
      span.button {
        display: inline-block;
        cursor: pointer;
        padding: 2px 8px;
        background: #4444ff;
        border-radius: 5px;
        color: white;
        transition: 0.3s;
      }
      span.button:hover {
        background: #0000dd;
        /* transform: scale(1.15); */
      }
      span.button:active {
        background: #0000cc;
        /* transform: scale(1.3); */
      }

      /* Looks like a link but is actually a "button" */
      span.linklike {
        color: #0000dd;
        cursor: pointer;
        text-decoration: underline;
      }

      /*
       * Animates the delete button for variable and function definitions
       */
      p.user-def {
        margin: .25em 0em;
      }
      p.user-def > span.delete-button:hover {
        background: #ff3333;
        /* transform: scale(1.15); */
      }
      p.user-def > span.delete-button:active {
        background: #ff0000;
        /* transform: scale(1.3); */
      }
      p.user-def > span.delete-button {
        display: inline-block; /* so that transform works */
        cursor: pointer;
        padding: 0em .25em;
        background: #ff7777;
        font-weight: bold;
        border-radius: 5px;
        color: white;
        transition: 0.1s;     
      }

      @media (hover: hover) {
        p.user-def > span.delete-button {
          visibility: hidden;
        }
      }

      p.user-def > span.delete-button:before {
        content: "\d7"; /* Unicode times character */
        /*
         * What follows is a fudge to raise the baseline slightly;
         * "times" is apparently designed to match lower-case characters.
         */
        position: relative;
        top: -0.06em;
      }
      p.user-def:hover > span.delete-button {
        visibility: visible;
      }

      /*
       * User symbol defs take the remaining space and scroll
       */
      div.sym-defs {
        flex: 1 1 auto;
        overflow: auto;
        max-height:100%;
      }

      /* The results box */
      div.results {
        border: 2px solid;
        margin: 12px 0px;
        padding: 0px 12px;
        border-radius: 5px;
      }
    </style>
  </head>
  <body>
    <div class="layout-column shrink-wrap">
      <div class="force-width legacy">
        <input type="text" style="text-align: right;"
          oninput="updateResult()" size="4" id="ft" value="5"> feet &nbsp;
        <input type="text" style="text-align: right;"
          oninput="updateResult()" size="2" id="inch" value="">
        <sup>
          <input type="text" style="text-align: right;"
            oninput="updateResult()" size="2" align="right" id="num" value="">
        </sup>/<sub>
          <input type="text" oninput="updateResult()" size="2" id="denom" value="8">
        </sub> inches
        &nbsp;&nbsp; times
        <input type="text" oninput="updateResult()" size="3" id="times" value="">
        &nbsp; divided by
        <input type="text" oninput="updateResult()" size="3" id="div" value="">
      </div>
      <div class="layout-row">
        <div class="expands">
          <input style="width: 100%;" type="text" id="expr" value=""
            autocomplete="off" autocorrect="off" autocapitalize="none"
            oninput="updateParse()" onchange="updateParse(true)">
        </div>
        <span class="button" style="margin-left: .25em; font-size: 1.125em"
          onclick="showHelp('help-expr')">?</span>
      </div>
      <div class="results">
        <p id="results">
          <span id="resultFt"></span> feet = <span id="resultFtDetail"></span>
          <br>
          <span id="resultIn"></span> inches = <span id="resultInDetail"></span>
          <br>
          <span id="resultMeters"></span> meters
          <br>
          <span id="resultMetersMetricFeet"></span> meters (assuming "metric feet")
        </p>
        <p id="numberResults">
          <span id="numberResultsDetail"></span>
        </p>
        <p id="error" style="color: red;"></p>
      </div>
      <div class="layout-row expands">
        <div class="sym-defs" id="symdefs"></div>
        <div><span class="button legacy" onclick="showHelp('help-tips')">Help</span></div>
      </div>
    </div>
    <div class="help" id="help-tips">
      <span class="close-button" onclick="showHelp()"></span>
      <div>
        <h2> Help </h2>
        <p> Some quick tips to get you started:
        <ul>
          <li> Input boxes can be left empty when not relevant.
          <li> A value like five and a half feet can be entered as 5.5 feet or as 5 feet 6 inches.
          <li> A value like six and a quarter inches can be entered as 6.25 inches or
               as 6 inches and 1/4.
          <li> You can type a fairly general expression into the text box. Click the
               <span class="button" onclick="showHelp('help-expr')">?</span> button
               for more information.
        </ul>
      </div>
    </div>
    <div class="help" id="help-expr">
      <span class="close-button" onclick="showHelp()"></span> 
      <div>
        <h2> Expressions </h2>
        <p> Expressions can contain numbers, units and the operators
            <code>+</code> <code>-</code> <code>*</code> <code>/</code>
            and <code>^</code> (exponentiation).
            Multiplication and division are performed before addition and subtraction, and
            parenthesis can be used for grouping. Spaces are generally optional.
        <p> Units include:
            <code>ft</code> <code>'</code> <code>in</code> <code>"</code> 
            <code>m</code> and <code>cm</code>.
        <p> As you type, the expression might be momentarily unparsable, e.g.,
            &ldquo;<code>3'+</code>&rdquo;, until you finish typing. 
            The results box will be grayed out while that happens.
            It would be too noisy to alert each of these errors, but if you don't 
            know why it's grayed out, you can hit &ldquo;enter&rdquo; to see an error message.
        <p> In these help boxes, most sample expressions, like
            <code>11'4"/2</code>, can be clicked to evaluate the expression.
        </p>
        <table class="stuff example">
          <tr>
            <th> Example
            <th> Description
          <tr>
            <td> 5' 6"
            <td> An ordinary distance
          <tr>
            <td> 5' 6 3/8" / 3
            <td> Divide 5 feet 6 and 3/8 inches by 3
          <tr>
            <td> 5 1/2' - 8"
            <td> Subtracts lengths
          <tr>
            <td> 5.5'
            <td> You can use decimal values instead of fractions
          <tr>
            <td> 3/4"
            <td> You can use just a fraction
          <tr>
            <td> (5'6" + 7') / 2
            <td> The average of 5'6" and 7'
          <tr>
            <td> 5'10 3/8" * 3/4
            <td> 3/4 of 5' 10 3/8"
          <tr>
            <td> 12' / 6"
            <td> The ratio of 12' and 6" (result is 24)
          <tr>
            <td> 1 + 2 * 3
            <td> Ordinary math (note order of operations; result is 7)
          <tr>
            <td> (1 + 2) * 3
            <td> Result is 9
          <tr>
            <td> 1m - 2cm
            <td> One meter minus two centimeters
         <tr>
            <td> ft
            <td> A foot
          <tr>
            <td> ft * 8
            <td> 8 feet; notice that named units are simply variables that have units
          <tr>
            <td> 5' 6" * pi
            <td> Circumference of a 5' 6" diameter circle
          <tr>
            <td> hyp(3', 4')
            <td> Hypotenuse of a right triangle with sides 3' and 4' (result is 5')
          <tr>
            <td> 1/4 mi2 / acres
            <td> The number of acres in a quarter of a square mile
        </table>
        <p> Just for fun, try <code>furlongs/fortnight</code> or <code>gallon/cup</code>.
        <h2> Terms </h2>
        <p> Expressions are built up out of <i>terms</i> which are either
          <ul>
            <li> A plain number such as <code>12</code>, <code>7.</code>,
                 <code>3.14</code>, <code>.15</code>, etc.
            <li> A variable name, such as <code>pi</code>
            <li> A <i>length</i> which can be a number, a fraction, or a number
                 and a fraction followed buy a <i>unit</i>
            <li> Any sequence of the the previous length-unit combinations as long as
                 the units are of descending size
          </ul>
        <h3> Units </h3>
        <p> Units are either the notations <code>'</code> and <code>"</code> for
            feet and inches or these named units:
        </p>
        <table class="stuff example">
          <tr>
            <th> Unit
            <th> Description
          <tr>
            <td> in
            <td> Inch
          <tr>
            <td> ft
            <td> Foot
          <tr>
            <td> yd
            <td> Yard
          <tr>
            <td> mi
            <td> Mile
          <tr>
            <td> acre
            <td> Acre
          <tr>
            <td> mm
            <td> Millimeter
          <tr>
            <td> cm
            <td> Centimeter
          <tr>
            <td> m
            <td> Meter
          <tr>
            <td> km
            <td> Kilometer
          <tr>
            <td> hectare
            <td> Hectare, or <code>100m &times; 100m</code>
          <tr>
            <td> litre
            <td> A volume of <code>10cm &times; 10 cm &times; 10 cm</code>.
        </table>
        <p> Other less common units are also defined.
            To see more, you can either
            read this <span class="linklike" onclick="showHelp('help-builtin')">summary</span>
            or look at
            <a href="https://gist.github.com/sjswitzer/77288511a213dd0d973d99a941ac909e">the code</a>.
        <p> Any <i>variable</i> you define with a unit can be used as
            a unit itself.
            For example, if you enter <code>cubit = 1 1/2'</code>, you can then use
            expressions like <code>3 cubit 5 1/2"</code>.
        <p> A unit can be immediately followed (without spaces) by a number which is
            the power of that unit. For instance, <code>3 yd2</code> is three square yards
            (27 square feet)
            and <code>2 ft3</code> is two cubic feet. If a unit specifier is immediately
            preceded by a <code>/</code> (without spaces), it is an inverse unit.
            For instance, <code>60 /ft2</code> means 60 per square foot.
            <code>144/ft2</code> means 144 per square foot or, equivalently, 1 per square inch
            (which is how it will display). <i>What</i> per square foot? Anything.
            Think &ldquo;ducks&rdquo; and you'll be on the right track.
        <p> Units must be specified in descending order.
            You can use <code>12'3"</code> but you can't use <code>12"3'</code>.
            This is to prevent accidentally typing <code>12'3'</code> when you really
            meant <code>12'3"</code>.
            You can type nonsense like <code>3 1/2m 3.5"</code> if you want, but you won't
            do it by accident.
        <p><i>Beware that spaces can occasionally make a big difference.</i>
            <code>1/2 in</code> or <code>1/2in</code> means half an inch,
            but <code>1 / 2 in</code> or even
            <code>1/ 2 in</code> means one over 2 inches. Just avoid putting spaces around
            the slash in a fractional unit and you'll be fine.
        <h2> Variables </h2>
        <p> To define variables type <code class="abstract">name = expression</code>
            then hit &ldquo;enter.&rdquo;
            For instance, <code>frontage = 45'4 3/4"</code>. You can then use those values
            in later expressions, e.g. <code>frontage/3</code>.
            Amusingly, perhaps, because <code>frontage</code> is a length, it can also be
            used as a unit: <code>1/3 frontage</code> or <code>1/3frontage</code>.
        <p> The variables <code>ft</code>, <code>in</code>, <code>m</code>, <code>cm</code>,
            etc. described in "Units" above
            are predefined for use as values or as units. The variable <code>pi</code> is
            predefined in case you care about circles.
            <span class="linklike" onclick="showHelp('help-builtin')">Reserved</span>
            predefined variables cannot be changed.
        <h2> Functions </h2>
        <p> Define functions to automate routine calculations by typing
            <code class="abstract">name(param,param,&hellip;) = expression</code>
            then hitting &ldquo;enter.&rdquo; For instance, you can define a function to average to numbers
            or lengths: <code>average(x,y) = (x+y)/2</code> (but the predefined function
            <code>mean(&hellip;)</code> already does that, so&hellip;).
        <p> Function bodies can use any of their parameters (<i>of course</i>) and variables
            that have already been defined. As a special case, a function with no parameters
            can be used as a &ldquo;dynamic variable.&rdquo; That is, assuming variables <code>a</code>
            and <code>b</code> are already defined, the function
            <code>ab() = a + b</code> can be invoked as <code>ab()</code> or <code>ab</code>,
            and in either case gives you the current value of <code>a + b</code>.
        <h3> Built-In Functions </h3>
        <table class="example">
          <tr>
            <th> Function
            <th> Description
          <tr>
            <td> mean(x,y,&hellip;) 
            <td> The average of a set of numbers or lengths
          <tr>
            <td> sum(x,y,&hellip;) 
            <td> The average of a set of numbers or lengths
          <tr>
            <td> hyp(x,y,&hellip;) 
            <td> The hypotenuse of a triangle or, more usefully, the diagonal of a rectangle
          <tr>
            <td> sqrt(x) 
            <td> Square root
          <tr>
            <td> cbrt(x) 
            <td> Cube root
          <tr>
            <td> sin(angle) 
            <td> Sine of an <i>angle</i> (must be units of radian or degree)
          <tr>
            <td> cos(angle) 
            <td> Cosine of an <i>angle</i> (must be units of radian or degree)
          <tr>
            <td> atan2(y, x) 
            <td> Returns the <i>angle</i> corresponding to the slope y/x, even when x is zero.
                 More formally, it's the angle from the x-axis of the vector (x,y).
        </table>
        <p> Note that angles are neither degrees nor radians. They are <i>just angles</i> and can be
            specified or displayed using either notation. If, however, a plain number is given, it will be
            interpreted as radians. Compare <code>sin(45 degrees)</code>, <code>sin(pi/4radian)</code>
            and <code>sin(pi/4)</code>. 
        <h2> Unit Conversions </h2>
        <p> To display results in terms of specific units, follow an expression by <code>|</code>
            then a unit.
            For instance, <code>100 km/hr | mi</code> displays the speed in miles/minute.
            <code>100 km/hr | hr</code> displays the speed in terms of miles/hour.
        <p> How many watts in 10 horsepower? <code>10 horsepower | W</code>.
            How many tablespoons in a cup? <code>cup | tbsp</code>.
            Sea-level air pressure in PSI? <code>atm | PSI</code>.
            What is 20 degrees celsius in fahrenheit? <code>20 celsius | fahrenheit</code>.
            What <i>is</i> 20000 leagues anyway? <code>20000 league | mi</code>.
            How far away is the Sun in miles? <code>au | mi</code>.
            What's the current with <code>5V</code> across a <code>2000 ohm</code> resister?
            <code>5V / 2000 ohm</code>
            What is <code>pi/4</code> radians in degrees? <code>pi/4 radians | degrees</code>.
        <p> How much does a gallon of water weigh in pounds? <code>kg/liter*gallon | lb</code>.
            How long does it take sunlight to reach the Earth? <code>au/c | min</code>
            What is a kilobyts per meter in kilometers? <code>KB/m | km</code>.
            It seems rather silly, but it might be a length of magnetic tape.
        <p> As an exercise (click the code that follows), suppose an elephant weighs
            <code>elephantWeight = 8000lbf</code>
            (for convenience, I've used <i>pounds of force</i>) and an elephant's foot is about
            <code>elephantFoot = 45cm</code> across, and it's standing evenly on four legs,
            then the pressure under its feet, expressed in pounds per square inch, is
            <code>elephantWeight/(pi*(elephantFoot/2)^2)/4 | PSI</code>, about 8 PSI.
        <h2> Metric Feet </h2>
        <p> Results presented in feet an inches show an alternate interpretetion assuming measurements
            are in "metric feet." A &ldquo;metric foot&rdquo; is a convention used by the construction
            industry in metric countries where a foot is taken to be exactly 30cm instead of 30.48cm.
            It's an
            <a href="https://en.wikipedia.org/wiki/ISO_2848#Metric_foot">international standard</a>.
        <h2> Odds & Ends </h2>
        <p> <span class="linklike" onclick="showHelp('help-boring')">Boring details</span>,
            if you're interested.
      </div>
    </div>
    <div class="help" id="help-boring">
      <span class="close-button" onclick="showHelp()"></span>
      <div>
        <h2> Boring Details </h2>
        <p> This program started out as a quick and dirty tool to easily divide
            lengths given in feet and inches into equal parts, a common task
            in the construction industry and quite tedious to work out by hand.
            If the file name or last URL element contains the string "inch" (any case),
            you'll see the original user interface. If you're curoius, you can
            <span class="linklike" onclick="toggleLegacyMode()">switch</code> the UI.
        <p> But I started to think of it as a <i>calculator</i> and wondered
            if it could be generalized to do arbitrary math with lengths.
            It's possible to add two lengths,
            resulting in another length, or to multiply or divide a length by a number.
            But you can't add a length and a number.
            You can divide a length by a length to get a number (the ratio of lengths).
            Can you multiply two lengths? Yes, but the result is an <i>area</i>.
        <p> This line of thinking leads to
            <a href="https://en.wikipedia.org/wiki/Dimensional_analysis">dimensional analysis</a>,
            and there are already some very good programs out there for that including the legendary
            <a href="https://linux.die.net/man/1/units">Unix "units" command</a>.
            Hell, <a href="https://www.google.com/search?q=12+acres+%2F+100+feet">
            Google will do it for you</a> if you ask it nicely. But I couldn't
            help myself, so I got carried away and ended up implementing a fairly
            general dimensional units calculator.
        <p> Verious interesting problems came up along the way, including issues of
            special-purpose language design, and maintaining full decimal precision
            in various units while using floating-point arithmetic (remember that 0.1
            can't be represented exactly in binary floating point).
        <p> Still, the main distinction of this tool is that it deals naturally with notations
            typically used with feet and inches. But, <i>sigh</i>,
            <a href="https://www.google.com/search?q=5%27+6+3%2F8%22+%2F+3">
            Google will do that for you too</a>.
        <p> Oh well, it was a good excuse to spiff up my HTML, CSS, and JavaScript skills.
            Not bad for a weekend project that got <i>way</i> out of hand.
        <p class="local-only"> You can also
            <a href="https://htmlpreview.github.io/?https://gist.githubusercontent.com/sjswitzer/77288511a213dd0d973d99a941ac909e/raw/UnitsCalc.html">
              run this from the web</a>.
        <p> A-B-C. A-Always. B-Be. C-Coding.
        <p> Copyright &copy; 2021, Stan Switzer
        <div style="float: left; margin: 0em .5em 4.5em 0em">
          <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">
            <img alt="Creative Commons License" style="border-width:0"
              src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png">
          </a>
        </div>
        <p> This work is licensed under a
          <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">
            Creative Commons Attribution-ShareAlike 4.0 International License
          </a>.
        <br> Find source on
          <a href="https://gist.github.com/sjswitzer/77288511a213dd0d973d99a941ac909e">GitHub</a>
      </div>
    </div>
    <div class="help" id="help-builtin">
      <span class="close-button" onclick="showHelp()"></span>
      <div>
        <h2> Built-In Constants and Units </h2>
        <p> This table is generated automatically from internal system data.
            It may not be pretty, but at least it's comprehensive.
        <p> Symbols that are reserved (that is, cannot be redefined) are noted.
        <p>
        <table class="stuff example2">
          <thead>
            <tr>
              <th> Symbol
              <th> Inverse
              <th> Description
            </tr>
          </thead>
          <tbody id="builtin-symbols">
          </tbody>
        </table>
      </div>
    </div>
    <script type="text/javascript">
      "use strict";

      // Errors that are too chatty to show while typing.
      //   (Error will be shown if the user hits "enter.")
      class ChattyError extends Error {
        constructor(msg) {
          super();
          this.message = msg;
        }
      }

      let logLevel = 0;

      class Dim {
        static isScalar(dim) {
          return Dim.nDims(dim) === 0;
        }

        static nDims (dim) {
          let n = 0;
          for (const measure in dim)
            if (dim[measure] !== 0)
              n += 1;
          return n;
        }

        static normSquared(dim) {
          // How far this dimension is from being scalar.
          let n = 0
          for (const measure in dim) {
            const m = dim[measure];
            if (m)
              n += m * m;
          }
          return n;
        }

        static equal(dim1 = {}, dim2 = {}) {
          for (const measure in dim1) {
            if ((dim1[measure] ?? 0) !== (dim2[measure] ?? 0))
              return false;
          }
          for (const measure in dim2)
            if ((dim1[measure] ?? 0) !== (dim2[measure] ?? 0))
              return false;
          return true;
        }

        static mul(dim = {}, n) {
          let ret = {};
          for (const measure in dim)
            ret[measure] = dim[measure]*n;
          return ret;
        }

        // If a dimension can be evenly divided, the new dimension, else null
        // We don't allow fractal dimensions in this town.
        static div(dim = {}, n) { 
        let ret = {};
          for (const measure in dim) {
            const expDiv = dim[measure]/n;
            if (expDiv !== Math.trunc(expDiv))
              return null;
            ret[measure] = expDiv;
          }
          return ret;
        }

        static add(dim1 = {}, dim2 ={}, factor = 1) {
          let measures = {}, ret = {};
          for (const measure in dim1)
            measures[measure] = true;
          for (const measure in dim2)
            measures[measure] = true;
          for (const measure in measures) {
            let exp = (dim1[measure] ?? 0) + factor*(dim2[measure] ?? 0);
            if (exp)
              ret[measure] = exp;
          }
          return ret;
        }

        static sub(dim1, dim2, factor = 1) {
          return Dim.add(dim1, dim2, -factor);
        }
      }

      // A curious thing worth noting: It turns out that fractions of the form
      // "n / power-of-2" are precicely the values that can be represented exactly
      // in floating point arithmetic and also the conventional way of expressing
      // fractional inches. So doing all arithmetic in units of inches means that
      // calculations can be exact when exact results are possible.
      //
      // It later occurred to me that doing calculations in metric units of a
      // hundredth of a centimeter or less would lead to exact results for both systems
      // most often. The largest SI unit that would serve is the micrometer.
      // But why not go further? Decimal fractions suffer in binary
      // representations. Many exact values in decimal must be approximated in binary.
      // But if you pick a small enough base unit, all integral values greater that
      // can be exact. For angles, pick a power of ten times 60*60 so that decimal angles
      // can be exact down to seconds because radians are never going to be exact anyway.
      // The unit for KELVIN is a multiple of 9 so that fahrenheit can be represented exactly.
      //
      // If an expression contains any US units, the results will be displayed in
      // those units. If an expression contains only metric units, the results
      // will be displayed in metric.

      const NM = 1000, UM = 1000*NM, MM = 1000*UM, CM = 10*MM, M  = 1000*MM, KM = 1000*M;
      const IN = 25400*UM, FT = 12*IN, MI = 5280*FT, NMI = 1852*M;
      const US = 1, MS = 1000*US, SEC = 1000*MS, MIN = 60*SEC, HR = 60*MIN; 
      const UG = 1000, MG = 1000*UG, GM = 1000*MG, KG = 1000*GM;
      const GAL = 231*IN**3, LBM = 453.59237*GM, LBF = 4.448222*KG*M/(SEC*SEC);
      const UAMP = 1000, MAMP = 1000*UAMP, AMP = 1000*MAMP, KELVIN = 9000000;
      const BIT = 1000000, BYTE = 8*BIT;
      const DEGREE = 60*60*1000, RADIAN = 180*DEGREE/Math.PI;
      const CANDLE = 1000000;

      let unitsSystem = 'mks';  // can also be 'cgs'

      const systemSymbols = {
        // Length (L)
        in: { type: 'num', dim: { L: 1 }, val: IN, desc: "inch", reserved: true, uscu: true,
            alt: ["inch", "inches"] },
        ft: { type: 'num', dim: { L: 1 }, val: FT, desc: "foot", reserved: true, uscu: true,
            alt: ["foot", "feet"] },
        yd: { type: 'num', dim: { L: 1 }, val: 3*FT, desc: "yard", uscu: true,
            alt: ["yard", "yards"] },
        link: { type: 'num', dim: { L: 1 }, val: 66*FT/100, desc: "surveyor's link", uscu: true, alt: ["links"] },
        rod: { type: 'num', dim: { L: 1 }, val: 66*FT/4, desc: "surveyor's rod", uscu: true, alt: ["rods"] },
        chain: { type: 'num', dim: { L: 1 }, val: 66*FT, desc: "surveyor's chain", uscu: true, alt: ["chains"] },
        furlong: { type: 'num', dim: { L: 1 }, val: 660*FT, uscu: true, alt: ["furlongs"] },
        mi: { type: 'num', dim: { L: 1 }, val: MI, desc: "mile", alt: ["mile", "miles"],
            reserved: true, uscu: true },
        nml: { type: 'num', dim: { L: 1 }, val: NMI, uscu: true,
            desc: "nautical mile" },
        league: { type: 'num', dim: { L: 1 }, val: 5.556*KM, uscu: true, alt: ["leagues"],
            desc: "nautical league" },
        nm: { type: 'num', dim: { L: 1 }, val: NM, desc: "nanometer" },
        um: { type: 'num', dim: { L: 1 }, val: UM, desc: "micrometer", display: "\u00B5m" },
        mm: { type: 'num', dim: { L: 1 }, val: MM, desc: "millimeter" },
        cm: { type: 'num', dim: { L: 1 }, val: CM, desc: "centimeter", reserved: true },
        m:  { type: 'num', dim: { L: 1 }, val: M, desc: "meter", reserved: true, alt: ["meter", "meters"] },
        km: { type: 'num', dim: { L: 1 }, val: KM, desc: "kilometer",
            alt: ["kilometer", "kilometers"] },
        au:  { type: 'num', dim: { L: 1 }, val: 149597870700*M, desc: "astronomical unit" },
        parsec:  { type: 'num', dim: { L: 1 }, val: 149597870700*M * 648000/Math.PI,
            desc: "astronomy, parallax of one arcsecond", alt: ["parsecs"] },
        
        // Area (L^2)
        acre: { type: 'num', dim: { L: 2 }, val: 66*FT * 660*FT, reserved: true, uscu: true, alt: ["acres"],
            desc: "66' \u00D7 660'" },
        township: { type: 'num', dim: { L: 2 }, val: (6*MI)**2, uscu: true, alt: ["townships"] },
        hectare: { type: 'num', dim: { L: 2 }, val: (100*M)**2, alt: ["hectares"],
            desc: "100 meters \u00D7 100 meters" },
        are: { type: 'num', dim: { L: 2 }, val: (10*M)**2, desc: "10 meters \u00D7 10 meters" },
        barn: { type: 'num', dim: { L: 2 }, val: 10e-28*M**2, alt: ["barns"] }, // Nuclear physicist in the house?
        darcy: { type: 'num', dim: { L: 2 }, val: 10e-12*M**2, desc: "hydraulic permeability" },

        // Volume (L^3)
        //    Sadly, there's ambiguity in units between liquid volume, dry volume, and mass
        //    and, further, differences between the US and Imperial systems.
        //    When in conflict, I've chosen liquid volumes and US units.
        // (liquid)
        gallon : { type: 'num', dim: { L: 3 }, val: GAL, uscu: true, alt: ["gallons"] },
        quart : { type: 'num', dim: { L: 3 }, val: GAL/4, uscu: true, alt: ["quarts"] },
        pint : { type: 'num', dim: { L: 3 }, val: GAL/8, uscu: true, alt:["pints"] },
        cup : { type: 'num', dim: { L: 3 }, val: GAL/16, uscu: true, alt: ["cups"] },
        gi : { type: 'num', dim: { L: 3 }, val: GAL/32, uscu: true, desc: "gill", alt:["gill", "gills"] },
        floz : { type: 'num', dim: { L: 3 }, val: GAL/128, desc: "fluid ounce", uscu: true },
        dram : { type: 'num', dim: { L: 3 }, val: GAL/128/8, uscu: true, alt: ["drams"] },
        minim : { type: 'num', dim: { L: 3 }, val: GAL/128/8/60, uscu: true, alt: ["minims"] },
        tbsp : { type: 'num', dim: { L: 3 }, val: GAL/256, desc: "tablespoon", uscu: true,
            alt: ["tbsps", "tablespoon", "tablespoons"] },
        tsp : { type: 'num', dim: { L: 3 }, val: GAL/768, desc: "teaspoon", uscu: true,
            alt: ["tsps", "teaspoon", "teaspoons"] },
        liter : { type: 'num', dim: { L: 3 }, val: (10*CM)**3, alt: ["liters", "litre", "litres"] },
        ml : { type: 'num', dim: { L: 3 }, val: (CM)**3, desc: "milliliter" },
        // (dry)
        cc : { type: 'num', dim: { L: 3 }, val: CM**3, desc: "cubic centimeter" },
        cord : { type: 'num', dim: { L: 3 }, val: 128*FT**3, desc: "cord of wood", uscu: true, alt: ["cords"] },

        // Time (T)
        us: { type: 'num', dim: { T: 1 }, val: US, desc: "microsecond", uscu: null, display: "\u00B5s" },
        ms: { type: 'num', dim: { T: 1 }, val: MS, desc: "millisecond", uscu: null },
        s: { type: 'num', dim: { T: 1 }, val: SEC, desc: "second", reserved: true, uscu: null,
            alt: ["second", "seconds", "sec", "secs"] },
        min: { type: 'num', dim: { T: 1 }, val: MIN, desc: "minute", uscu: null,
            alt: ["minute", "minutes", "mins"] },
        hr: { type: 'num', dim: { T: 1 }, val: HR, desc: "hour", uscu: null, alt: ["hour", "hours", "hrs"] },
        day: { type: 'num', dim: { T: 1 }, val: 24*HR, uscu: null, alt: ["days"] },
        week: { type: 'num', dim: { T: 1 }, val: 24*7*HR, desc: "7 days", uscu: null, alt: ["weeks"] },
        fortnight: { type: 'num', dim: { T: 1 }, val: 24*14*HR, desc: "2 weeks", uscu: null, alt: ["fortnights"] },
        hz: { type: 'num', dim: { T: -1 }, val: 1/SEC, desc: "second", desc: "hertz", uscu: null, alt: ["hertz"] },

        // Velocity (L T^-1)
        knot: { type: 'num', dim: { L: 1, T: -1 }, val: NMI/HR, uscu: true, alt: ["knots"],
            desc: "nautical mile per hour" },

        // Mass (M)
        lb: { type: 'num', dim: { M: 1 }, val: LBM, desc: "pound mass", uscu: true, alt: ["lbs", "pound", "pounds"] },
        oz: { type: 'num', dim: { M: 1 }, val: LBM/16, desc: "ounce mass", uscu: true, alt: ["ounce", "ounces"]},
        grain: { type: 'num', dim: { M: 1 }, val: LBM/7000, uscu: true },
        stone: { type: 'num', dim: { M: 1 }, val: 14*LBM, uscu: true, desc: "UK stone" }, // no alt "stones"
        hundredweight: { type: 'num', dim: { M: 1 }, val: 112*LBM, uscu: true,
            desc: "UK hundredweight" },  // in the US it's 100lb, but nobody uses it so...
        longton: { type: 'num', dim: { M: 1 }, val: 2240*LBM, uscu: true, alt: ["longtons"],
            desc: "UK long ton" },
        ton: { type: 'num', dim: { M: 1 }, val: 2000*LBM, uscu: true, alt: ["tons"],
            desc: "US ton" },
        tonne: { type: 'num', dim: { M: 1 }, val: 1000*KG, alt: ["tonnes"],
            desc: "metric ton" },
        carat: { type: 'num', dim: { M: 1 }, val: 200*MG, alt: ["carats"] },
        ug: { type: 'num', dim: { M: 1 }, val: UG, desc: "microgram", display: "\u00B5g" },
        mg: { type: 'num', dim: { M: 1 }, val: MG, desc: "milligram" },
        gm: { type: 'num', dim: { M: 1 }, val: GM, reserved: true, desc: "gram",
            alt: ["gram", "grams"] },
        kg: { type: 'num', dim: { M: 1 }, val: KG, reserved: true, desc: "kilogram",
            alt: ["kilogram", "kilograms"] },
        dalton: { type: 'num', dim: { M: 1 }, val: 1.6605390666e-27*KG },

        // Force (L M T^-2)
        N: { type: 'num', dim: { L: 1, M: 1, T:-2 }, val: KG*M/(SEC*SEC), desc: "newton",
            alt: ["newton", "newtons"] },
        dyne: { type: 'num', dim: { L: 1, M: 1, T:-2 }, val: KG*M/(SEC*SEC)/100000, alt: ["dynes"] },
        lbf: { type: 'num', dim: { L: 1, M: 1, T:-2 }, val: LBF, desc: "pound force", uscu: true },

        // Energy (L^2 M, T^-2)
        joule: { type: 'num', dim: { L: 2, M: 1, T:-2 }, val: KG*M*M/(SEC*SEC), alt: ["joules"] },
        erg: { type: 'num', dim: { L: 2, M: 1, T:-2 }, val: KG*M*M/(SEC*SEC)/10000000, alt: ["ergs"] },

        // Power (L^2 M T^-3)
        W: { type: 'num', dim: { L: 2, M: 1, T:-3 }, val: KG*M*M/(SEC*SEC*SEC), desc: "watt",
            alt: ["watt", "watts"] },
        kW: { type: 'num', dim: { L: 2, M: 1, T:-3 }, val: 1000*KG*M*M/(SEC*SEC*SEC), desc: "kilowatt",
            alt: ["kilowatt", "killowatts"] },
        mW: { type: 'num', dim: { L: 2, M: 1, T:-3 }, val: KG*M*M/1000/(SEC*SEC*SEC), desc: "milliwatt" },
        horsepower: { type: 'num', dim: { L: 2, M: 1, T:-3 }, val: 550*FT*LBF/SEC, desc: "mechanical horsepower", uscu: true },

        // Pressure (L^-1 M T^-2)
        Pa: { type: 'num', dim: { L: -1, M: 1, T:-2 }, val: KG/(M*SEC*SEC), desc: "pascal",
            alt: ["pascal", "pascals"] },
        kPa: { type: 'num', dim: { L: -1, M: 1, T:-2 }, val: 1000*KG/(M*SEC*SEC),
            desc: "kilopascal" },
        PSI: { type: 'num', dim: { L: -1, M: 1, T:-2 }, val: LBF/(IN*IN),
            desc: "pounds per square inch", uscu: true },
        atm: { type: 'num', dim: { L: -1, M: 1, T:-2 }, val: 101325*KG/(M*SEC*SEC),
            desc: "atmosphere" },
        bar: { type: 'num', dim: { L: -1, M: 1, T:-2 }, val: 100000*KG/(M*SEC*SEC), alt: ["bars"] },
        millibar: { type: 'num', dim: { L: -1, M: 1, T:-2 }, val: 100*KG/(M*SEC*SEC),
            alt: ["millibars"] },

        // Electricity (A ...)
        //   http://www.ebyte.it/library/educards/sidimensions/SiDimensionsAlfaList.html
        A: { type: 'num', dim: { A: 1 }, val: AMP, reserved: true, desc: "ampere",
            alt: ["ampere", "amperes", "amp", "amps"]  },
        mA: { type: 'num', dim: { A: 1 }, val: MAMP, desc: "milliampere" },
        uA: { type: 'num', dim: { A: 1 }, val: UAMP, desc: "microampere", display: "\u00B5A" },
        V: { type: 'num', dim: { M: 1, L: 2, T: -3, A: -1 }, val: KG * M**2 / SEC**3 / AMP,
            desc: "volt" },
        kV: { type: 'num', dim: { M: 1, L: 2, T: -3, A: -1 }, val: 1000*KG * M**2 / SEC**3 / AMP,
            desc: "kilovolt" },
        mV: { type: 'num', dim: { M: 1, L: 2, T: -3, A: -1 }, val: KG/1000 * M**2 / SEC**3 / AMP,
            desc: "millivolt" },
        uV: { type: 'num', dim: { M: 1, L: 2, T: -3, A: -1 }, val: KG/1000**2 * M**2 / SEC**3 / AMP,
            desc: "microvolt", display: "\u00B5V" },
        ohm: { type: 'num', dim: { M: 1, L: 2, T: -3, A: -2 }, val: KG * M**2 / SEC**3 / AMP**2,
            desc: "ohm", display: "\u03A9" },
        kohm: { type: 'num', dim: { M: 1, L: 2, T: -3, A: -2 }, val: 1000*KG * M**2 / SEC**3 / AMP**2,
            desc: "kiloohm", display: "k\u03A9" },  // sp?
        S: { type: 'num', dim: { M: -1, L: -2, T: 3, A: 2 }, val: SEC**3 * AMP**2 / KG / M**2,
            desc: "siemens" },
        C: { type: 'num', dim: { T: 1, A: 1 }, val: SEC*AMP, desc: "coulomb" },
        // farads tend to be very small
        F: { type: 'num', dim: { M: -1, L: -2, T: 4, A: 2 }, val: SEC**4 * AMP**2 / KG / M**2,
            desc: "farad" },
        mF: { type: 'num', dim: { M: -1, L: -2, T: 4, A: 2 }, val: SEC**4 * AMP**2 / KG / M**2 / 1000,
            desc: "millifarad" },
        uF: { type: 'num', dim: { M: -1, L: -2, T: 4, A: 2 }, val: SEC**4 * AMP**2 / KG / M**2 / 1000**2,
            desc: "microfarad", display: "\u00B5F" },
        nF: { type: 'num', dim: { M: -1, L: -2, T: 4, A: 2 }, val: SEC**4 * AMP**2 / KG / M**2 / 1000**3,
            desc: "nanofarad" },
        pF: { type: 'num', dim: { M: -1, L: -2, T: 4, A: 2 }, val: SEC**4 * AMP**2 / KG / M**2 / 1000**4,
            desc: "picofarad" },
        Wb: { type: 'num', dim: { M: 1, L: 2, T: -2, A: -1 }, val: KG * M**2 / SEC**2 / AMP,
            desc: "weber, magnetic flux" },
        T: { type: 'num', dim: { M: 1, T: -2, A: -1 }, val: KG / SEC**2 / AMP,
            desc: "tesla, magnetic flux density" },
        gauss: { type: 'num', dim: { M: 1, T: -2, A: -1 }, val: KG / SEC**2 / AMP / 10000,
            desc: "gauss, magnetic flux density" },
        H: { type: 'num', dim: { M: 1, L: 2, T: -2, A: -2 }, val: KG * M**2 / SEC**2 / AMP**2,
            desc: "henry, mutual inductance " },

        // Information (BIT)
        bit: { type: 'num', dim: { BIT: 1 }, reserved: true, val: BIT, alt: ["bits"] },
        baud: { type: 'num', dim: { BIT: 1, T: -1 }, val: BIT/SEC },
        kbaud: { type: 'num', dim: { BIT: 1, T: -1 }, val: 1000*BIT/SEC, desc: "kilobaud" },
        byte: { type: 'num', dim: { BIT: 1 }, reserved: true, val: BYTE, alt: ["bytes"] },
        // I personally find this offensive, but the modern consensus is that the well-named
        // units here are powers of 10 and the stupidly-named ones are powers of 2.
        //   https://www.ibm.com/docs/en/storage-insights?topic=overview-units-measurement-storage-data
        KB: { type: 'num', dim: { BIT: 1 }, val: 10**3 * BYTE, desc: "kilobyte" },
        MB: { type: 'num', dim: { BIT: 1 }, val: 10**6 * BYTE, desc: "megabyte" },
        GB: { type: 'num', dim: { BIT: 1 }, val: 10**9 * BYTE, desc: "gigabyte" },
        TB: { type: 'num', dim: { BIT: 1 }, val: 10**12 * BYTE, desc: "terabyte" },
        PB: { type: 'num', dim: { BIT: 1 }, val: 10**15 * BYTE, desc: "petabyte" },
        EB: { type: 'num', dim: { BIT: 1 }, val: 10**18 * BYTE, desc: "exabyte" },
        KiB: { type: 'num', dim: { BIT: 1 }, val: 2**10 * BYTE, desc: "kibibyte" },
        MiB: { type: 'num', dim: { BIT: 1 }, val: 2**20 * BYTE, desc: "mebibyte" },
        GiB: { type: 'num', dim: { BIT: 1 }, val: 2**30 * BYTE, desc: "gibibyte" },
        TiB: { type: 'num', dim: { BIT: 1 }, val: 2**40 * BYTE, desc: "tebibyte" },
        PiB: { type: 'num', dim: { BIT: 1 }, val: 2**50 * BYTE, desc: "pebibyte" },
        EiB: { type: 'num', dim: { BIT: 1 }, val: 2**60 * BYTE, desc: "exbibyte" },

        // Temperature (Q)
        K: { type: 'num', dim: { Q: 1 }, val: KELVIN, reserved: true, desc: "kelvin",
            alt: ["kelvin", "kelvins"] },
        celsius: { type: 'num', dim: { Q: 1 }, val: KELVIN, origin: 273.15*KELVIN,
            desc: "Celsius" },
        fahrenheit: { type: 'num', dim: { Q: 1 }, val: 5*KELVIN/9, origin: (273.15-32*5/9)*KELVIN,
            desc: "Fahrenheit" },

        // Angles (RAD)
        //   A steradian can be thought of as a square radian because 2pi radians covers
        //   a circle and 4pi steradians covers a sphere. Even if not completely
        //   sound, there are no operations on it that are harmed by the assumption.
        radian: { type: 'num', dim: { RAD: 1 }, reserved: true, val: RADIAN, alt: ["radians"] },
        sr: { type: 'num', dim: { RAD: 2 }, val: RADIAN**2, desc: "steradian",
            alt: ["steradian", "steradians"] },
        degree: { type: 'num', dim: { RAD: 1 }, val: DEGREE, alt: ["degrees"] },

        // Luminosity (CD...)
        cd: { type: 'num', dim: { CD: 1 }, val: CANDLE, reserved: true, desc: "candle, luminous intensity" },
        lx: { type: 'num', dim: { CD: 1, RAD: 2, L: -2 }, val: CANDLE * RADIAN**2 / M**2,
            desc: "lux, luminous emittance" },
        lm: { type: 'num', dim: { CD: 1, RAD: 2 }, val: CANDLE * RADIAN**2,
            desc: "lumen, luminous flux" },

        // Acoustics
        reyl: { type: 'num', dim: { M: 1, L: -2, T: -1 }, val: KG / M**2 / SEC,
            desc: "reyl, acoustic reactance" },

        // Interesting constants (various)
        pi: { type: 'num', dim: {}, val: Math.PI },
        tau: { type: 'num', dim: {}, val: 2*Math.PI, desc: "2 \u00D7 pi" },  // :)
        dozen: { type: 'num', dim: {}, val: 12 },  // :)
        mol: { type: 'num', dim: {}, val: 6.02214076e23, desc: "Avogadro's number" },
        boltz: { type: 'num', dim: { L: 2, M: 1, T:-2, Q: -1 }, val: 1.380649e-23*KG*M*M/(SEC*SEC)/KELVIN,
            desc: "Boltzmann constant" },
        g: { type: 'num', dim: { L: 1, T:-2 }, val: 9.80665*M/(SEC*SEC),
             desc: "standard gravity (earth)"},
        G: { type: 'num', dim: { L: 3, M: -1, T:-2 }, val: 6.6743e-11*M*M*M/(KG*SEC*SEC),
             desc: "universal gravitational constant" },
        c: { type: 'num', dim: { L: 1, T:-1 }, val: 299792458*M/SEC, desc: "speed of light"},

        // General n-dimensional hypotenuse
        hyp: function Hypotenuse(...params) {
          if (params.length < 1)	
            return { type: 'num', dim: {}, val: 0 };
          let res = reduceParamVals(this.sym, 0, params, (accum, val) => accum + val*val);
          return { ...res, val: Math.sqrt(res.val) };
        },

        mean: function(...params) {
          if (params.length < 1) throw `${this.sym}(): No parameters`;
          let res = reduceParamVals(this.sym, 0, params, (accum, val) => accum + val);
          return { ...res, val: res.val/params.length };
        },

        sum: function(...params) {
          if (params.length < 1) throw `${this.sym}(): No parameters`;
          let res = reduceParamVals(this.sym, 0, params, (accum, val) => accum + val);
          return { ...res, val: res.val };
        },

        abs: function AbsoluteValue(...params) {
          if (params.length !== 1) throw `${this.sym}(): Requires one parameter`;
          let val = params[0];
          if (val.type !== 'num') throw `${this.sym}(): Requires numeric parameter`;
          return { ...val, val: Math.abs(val.val) };
        },

        sign: function(...params) {
          if (params.length !== 1) throw `${this.sym}(): Requires one parameter`;
          let val = params[0];
          if (val.type !== 'num') throw `${this.sym}(): Requires numeric parameter`;
          return { ...val, val: Math.sign(val.val), dim:{} };
        },

        // Square root
        sqrt: function SquareRoot(...params) {
          if (params.length !== 1) throw `${this.sym}(): Needs one parameter`;
          let val = params[0];
          if (val.type !== 'num') throw `${this.sym}(x): Illegal parameter`;
          let dim = Dim.div(val.dim, 2);
          if (!dim) throw `${this.sym}(x): parameter must have even units`;
          return { type: 'num', dim, val: Math.sqrt(numVal(val)), uscu: val.uscu };
        },

        // Cube root
        cbrt: function CubeRoot(...params) {
          if (params.length !== 1) throw `${this.sym}(): Needs one parameter`;
          let val = params[0];
          if (val.type !== 'num') throw `${this.sym}(x): Illegal parameter`;
          let dim = Dim.div(val.dim, 3);
          if (! dim) throw `${this.sym}(x): parameter must have even units`;
          return { type: 'num', dim, val: Math.cbrt(numVal(val)), uscu: val.uscu };
        },

        // Some trig functions that are valid over their whole domain, are somewhat useful,
        // and illustrate interesting things about dimensional analysis.
        sin: function Sine(...params) {
          if (params.length !== 1) throw `${this.sym}(): Needs one parameter`;
          let val = params[0];
          if (val.type !== 'num') throw `${this.sym}(x): Illegal parameter`;
          if (Dim.isScalar(val.dim))
            return { type: 'num', val: Math.sin(numVal(val)), dim: {} };
          if (!Dim.equal(val.dim, { RAD: 1 })) throw `${this.sym}(x): Parameter must be an angle`;
          return { type: 'num', val: Math.sin(numVal(val)/RADIAN), dim: {} };
        },

        cos: function Cosine(...params) {
          if (params.length !== 1) throw `${this.sym}(): Needs one parameter`;
          let val = params[0];
          if (val.type !== 'num') throw `${this.sym}(x): Illegal parameter`;
          if (Dim.isScalar(val.dim))
            return { type: 'num', val: Math.cos(numVal(val)), dim: {} };
          if (!Dim.equal(val.dim, { RAD: 1 })) throw `${this.sym}(x): Parameter must be an angle`;
          return { type: 'num', val: Math.cos(numVal(val)/RADIAN), dim: {} };
        },

        atan2: function ArctangentOfRatio(...params) {
          if (params.length !== 2) throw `${this.sym}(): Needs two parameters`;
          let val1 = params[0], val2 = params[1];
          if (!Dim.equal(val1.dim, val2.dim)) throw `${this.sym}(): Parameter types incompatible`;
          return { type: 'num', val: Math.atan2(numVal(val1), numVal(val2))*RADIAN, dim: { RAD: 1 } };
        },

        // Sets MKS or CGS preference
        MKS: function SetMKS() { unitsSystem = 'mks'; return { type: 'num', dim: {}, val: 0}; },
        CGS: function SetCGS() { unitsSystem = 'cgs'; return { type: 'num', dim: {}, val: 0}; },

        // For debugging, call saveUserSymbols.
        //    (it's hard to debug when the window is closing) 
        SAVE: function DebugSaveSyms() { saveUserSymbols(); return { type: 'num', dim: {}, val: 0}; },

        // Set logging level
        Logging: function SetLogLevel(...params) {
          if (params.length !== 1) throw `${this.sym}(): Needs one parameter`;
          let val = params[0];
          if (val.type !== 'num' || !Dim.isScalar(val.dim) || numVal(val) < 0 ) throw `${this.sym}(x): Illegal parameter`;
          let oldLevel = logLevel;
          logLevel = numVal(val);
          return { type: 'num', dim: {}, val: oldLevel };
        },
      };

      for (const [name, sym] of Object.entries(systemSymbols)) {
        if (sym.alt)
          for (const alt of sym.alt)
            systemSymbols[alt] = { ...sym, altOf: name, alt: undefined };
        if (sym.display)
        systemSymbols[sym.display] = { ...sym, altOf: name, display: undefined };
      }

      function reduceParamVals(name, accum, params, fn) {  // fn => (accum, val) => val
        let dim;
        let uscu = false;
        for (const val of params) {
          if (val.type !== 'num') throw `${name}(): Illegal parameter`;
          const value = numVal(val);
          if (value !== 0) {
            if (dim && !Dim.equal(val.dim, dim))
              throw new ChattyError(`${name}(): Parameter types incompatible`);
            dim = val.dim;
            accum = fn(accum, value);
            uscu = uscu || val.uscu;
          }
        }
        if (!dim)
          dim = {}
        return { type: 'num', dim, val: accum, uscu };
      }

      const userSymbols = {};
      let environment = {};

      function getSymbol(symName, opts) {
        let val = environment[symName];
        if (val === undefined)
          val = userSymbols[symName];
        if (val === undefined)
          val = systemSymbols[symName];
        if (val instanceof Function)
          val = { type: 'fn',  params:["..."], native: val,
            body: `#BuiltinFunction-${val.name}#` };
        if (!val) {
          // special case to create pseudo-variables for exponentiated units
          let pos = symName.length;
          while (pos > 1 && DIGITS.includes(symName.charAt(pos-1)))
            pos -= 1;
          if (pos < symName.length) {
            const symPrefix = symName.substr(0, pos);
            const symSuffix = symName.substr(pos);
            let val2 = getSymbol(symPrefix);
            let exp = Number(symSuffix);
            if (val2 && val2.type === 'num' && !Dim.isScalar(val2.dim) && val2.dim &&!val2.origin && exp > 1) {
              let desc = val2.desc && `${val2.desc ?? match[1]}^${String(exp)}`;
              return { sym: symName, type: 'num', dim: Dim.mul(val2.dim, exp), val: Math.pow(numVal(val2), exp),
                desc, reserved: val2.reserved, uscu: val2.uscu };
            }
          }
        }
        if (val && !val.sym)
          val.sym = symName;
        return val;
      }

      function invokeFunction(symVal, params) {
        if (symVal.type !== 'fn') throw new ChattyError("Not a function");
        if (symVal.native)
          return symVal.native(...params);   // symVal is "this" in a native function
        if (params.length !== symVal.params.length)
           throw new ChattyError(`incorrect number of params for ${symVal.sym}(${symVal.params.join(',')})`);
        const saveEnv = environment, saveParseStr = parseStr, saveParsePos = parsePos;
        try {
          parseStr = symVal.body;
          parsePos = 0;
          environment = {};
          for (const i in params)
            environment[symVal.params[i]] = params[i];
          let val = parseExpr();
          skipSpaces();
          if (peekc()) throw "Invalid function";
          return val;
        }
        finally {
          environment = saveEnv;
          parseStr = saveParseStr;
          parsePos = saveParsePos;
        }
      }

      const DIGITS_PRECISION = 10, EPSILON = Math.pow(10, -DIGITS_PRECISION);

      // fetch unit values and filter out any non-units (user may have redefined some)
      function filterUnits(unitSyms) {
        return unitSyms.map(sym => getSymbol(sym))
          .filter(val => val.type === 'num' && val.val && !Dim.isScalar(val.dim));
      }

      // The first unit listed is prefered over later units with the same
      // favorability. So it's important to have 'sr' before 'radian', for example.
      const commonUnits = [ // Ensure a covering basis of units in all cases
        'A', 'mA', 'uA', 'V', 'kV', 'mV','uV', 'Wb',
        'ohm', 'kohm', 'F', 'mF', 'uF', 'nF', 'pF', 
        'bit', 'byte', 'baud',
        'KB',  'MB',  'GB',  'TB',  'PB',  'EB',
        // seconds come after electrical and information units so that a coulomb
        // is an "A s", not an "s A"
        's', 'K',
        'sr', 'radian', 'cd', 'lx', 'lm' ];
      const commonMetricUnits = [
        'joule', 'N', 'Pa', 'kPa', 'W', 'kW', 'mW' ];
      const candidateUnits = filterUnits([
        ...commonUnits, ... commonMetricUnits,
        'in', 'ft', 'mi', 'acre',
        'tsp', 'tbsp', 'floz', 'cup', 'pint', 'quart', 'gallon',
        'lbf', 'oz', 'lb',
        'um', 'mm', 'cm', 'm', 'km', 'ml', 'liter',
        'gm', 'kg',
        'min', 'hr', // 'us', 'ms' -- don't include or you get m/s as um/us!
      ]);
      const candidateUnitsMKS = filterUnits([ ...commonUnits, ...commonMetricUnits, 'kg', 'm' ]);
      const candidateUnitsCGS = filterUnits([ ...commonUnits, ...commonMetricUnits, 'gm', 'cm' ]);
      const candidateUnitsUSCU = filterUnits([ ...commonUnits, 'lbf', 'ft', 'lb' ]);

      function val2str(val, opts) {
        let descStr = "", leadingTerm = val.leadingTerm;
        if (opts?.describe && val.desc)
          descStr = ` (${val.desc})`;
        let unitsStr = "", invUnitsStr = "";
        if (val.val !== undefined) {
          let uscu = !!val.uscu;
          if (leadingTerm) {
            uscu = leadingTerm.uscu;
            descStr = "";
          }
          let dim = val.dim;
          val = numVal(val);
          let allowedCandidateUnits = candidateUnits;
          if (dim.L && dim.M || dim.A || dim.DC) {
            // Things get weird when both mass and length are in a value. It's best
            // to revert to barebones CGS, MKS, or basic USCS units. Otherwise you get
            // things like "km cg" instead of "m gm"
            if (uscu)
              allowedCandidateUnits = candidateUnitsUSCU;
            else if (unitsSystem === 'mks' || opts?.saveMode)
              allowedCandidateUnits = candidateUnitsMKS;
            else if (unitsSystem === 'cgs')
              allowedCandidateUnits = candidateUnitsCGS;
          }
          // Find best units to express the value in
          let iterations = 0;
          while (!Dim.isScalar(dim)) {
            if (++iterations > 100)
              throw "Failed to reduce units";
            let unitDescs = [];
            let candidates = allowedCandidateUnits;
            if (leadingTerm)
              candidates = [leadingTerm];
            for (const unit of candidates) {
              let normSquared = Dim.normSquared(dim);
              let exp = 0, unitExp = 0;
              for (let i = 1; i < 100; ++i) {
                let normSquaredPos = Dim.normSquared(Dim.add(dim, unit.dim, -i));
                let normSquaredNeg = Dim.normSquared(Dim.add(dim, unit.dim, i));
                if (normSquaredPos < normSquared) {
                  normSquared = normSquaredPos;
                  exp = i;
                } else if (normSquaredNeg < normSquared) {
                  normSquared = normSquaredNeg;
                  exp = -i;
                } else {
                  break;
                }
              }
              if (exp === 0)
                  continue;
              for (const ue of Object.values(unit.dim))
                if (ue)
                  unitExp += ue;
              const reduced = Dim.add(dim, unit.dim, -exp);
              const reducedNDims = Dim.nDims(reduced);
              const reducerNDims = Dim.nDims(unit.dim);
              let origin = unit.origin ?? 0;
              let newVal;
              if (exp >= 0) 
                newVal = (val-origin) / Math.pow(unit.val, exp);
              else
                newVal = (val - origin) * Math.pow(unit.val, -exp);
              unitDescs.push({unit, exp, unitExp, newVal, normSquared, reduced, reducedNDims, reducerNDims});
            }
            unitDescs.sort((a,b) => {  // Note that we're sorting from best to worst
              function cmp(a,b) {
                // Units system should match
                //   (unit.uscu === null is a hack for units like time that are universal)
                if (a.unit.uscu !== null && b.unit.uscu !== null
                    && !a.unit.uscu !== !b.unit.uscu) {
                  if (!uscu === !a.unit.uscu)
                    return -1;
                  return 1;
                }

                // The fewer independend dimensions remaining, the better
                let dimDiff = a.reducedNDims - b.reducedNDims;
                if (dimDiff !== 0)
                  return dimDiff;

                // The fewer dimensions in the reducer, the better
                dimDiff = a.reducerNDims - b.reducerNDims;
                if (dimDiff !== 0)
                  return dimDiff;

                // The closer to scalar the better
                let normDiff = a.normSquared - b.normSquared;
                if (normDiff !== 0)
                  return normDiff;

                // Favor units that reduce the denominator
                let expDiff = Math.sign(a.exp * a.unitExp) - Math.sign(b.exp * b.unitExp);
                if (expDiff !== 0)
                  return expDiff;

                // Values greater than get a special bonus in the calculation below.
                // The idea is that anything over a meter should be expressed in meters
                // and less in lower units. But the inverse of cord (/cord) comes out
                // to some ridiculous number of cubic miles and it really should be cubic feet.
                // so being over 1 should give a bonus over the "distance from 1", but should
                // not be absolute.
                const aa = Math.abs(a.newVal), bb = Math.abs(b.newVal);

                // Values closer to 1 win
                let va = Math.abs(Math.log10(Math.abs(a.newVal))) - (aa >= 1 ? 5 : 0);
                let vb = Math.abs(Math.log10(Math.abs(b.newVal))) - (bb >= 1 ? 5 : 0);
                if (!isFinite(va) || !isFinite(vb)) {
                  if (isFinite(va))
                    return -1;
                  if (isFinite(vb))
                    return 1;
                  return 0;
                }
                return va - vb;
              }
              // ensure comparitor is well-behaved
              let res = cmp(a,b), rev = cmp(b,a);
              if (res !== -rev)
                throw "bad comparitor";
              return res;
            });
            if (logLevel > 1)
               console.log("======== " + parseStr + " unit candidates for " + val + " " +
                 JSON.stringify(dim) + " ========\n" + JSON.stringify(unitDescs, null, 2));
            if (unitDescs.length < 1) {
              if (leadingTerm) throw `Unit "${leadingTerm.sym}" does not reduce expression`;
              throw "system error: insufficient basis units";
            }
            leadingTerm = undefined;
            const unitDesc = unitDescs[0];
            let str = " ";
            let displayExp = unitDesc.exp;
            if (displayExp < 0) {
              displayExp = -displayExp;
              str += " /"
            }
            if (unitDesc.unit.display && !opts?.saveMode)
              str += unitDesc.unit.display;
            else
              str += unitDesc.unit.sym;
            if (displayExp !== 1) {
              let expStr = String(displayExp);
              if (opts?.html)
                expStr = `<sup>${expStr}</sup>`;
              str += expStr;
            }
            if (unitDesc.exp < 0)
              invUnitsStr += str;
            else
              unitsStr += str;
            val = unitDesc.newVal;
            dim = unitDesc.reduced;
          }
        }
        if (opts?.saveMode) {
          // full precision value
          return String(val) + unitsStr + invUnitsStr;
        }
        let absVal = Math.abs(val);
        if (absVal > 0 && absVal < 1) {
          // We want to display things like 0.0000001 when possible, but not if
          // signigicant digits are hanging out behind the truncation
          let val2 = absVal * 10**DIGITS_PRECISION;
          if (Math.trunc(val2) === 0 || val2 - Math.trunc(val2) > EPSILON)
            return String(val) + unitsStr + invUnitsStr + descStr;
        }
        // Avoids display of nonsense like 2.5000...001 while
        // maintaining accuracy to "DIGITS_PRECISION" decimal digits.
        val = val.toFixed(DIGITS_PRECISION);
        while (val.endsWith("0"))
          val = val.substr(0, val.length-1);
        if (val.endsWith("."))
          val = val.substr(0, val.length-1);
        return val + unitsStr + invUnitsStr + descStr;
      }

      //
      // Simple interface for common operations
      //

      function getField(name, def) {
        document.getElementById(name).style.color = '';
        let val = document.getElementById(name).value.trim();
        if (val === "") return def;
        val = parseFloat(val);
        if (isNaN(val) || (val === 0 && def !== 0))
          document.getElementById(name).style.color = 'red';
        return val;
      }

      function updateResult() {
        try {
          const ft = getField('ft', 0);
          const inch = getField('inch', 0);
          const num = getField('num', 0);
          const denom = getField('denom', 1);
          const times = getField('times', 1);
          const div = getField('div', 1);
          if (denom === 0 || div === 0) throw "Divide by zero";

          let totalInches = (ft*12 + inch + num/denom) * times / div;
          if (isNaN(totalInches)) throw "Bad input";
          if (!isFinite(totalInches)) throw "Divide by zero"

          showFeetInchesResult(totalInches*IN, { updateExpr: true });
        }
        catch (e) {
          showError(e);
        }
      }

      function showError(e, opts) {
        // always update the text, in case the error box is already showing
        let msg = e;
        if (e instanceof ChattyError)
          msg = e.message;
        document.getElementById('error').textContent = String(msg);
        if (!opts?.allErrors && e instanceof ChattyError)
          return;
        // we had an error so hide the results block and show the error block
        document.getElementById('results').style.display = 'none';
        document.getElementById('numberResults').style.display = 'none';
        document.getElementById('error').style.display = '';
      }

      //
      // Parser, for general calculation with expressions
      //

      let parseStr = "", initialParseStr = "";
      let parsePos = 0, parseFurthest = 0;
      const DIGITS = "0123456789";
      const ALPHA =
        "abcdefghijklmnopqrstuvwxyz" +
        "ABCDEFGHIJKLMNOPQRSTUVWXYZ" + "\u00B5\u03A9";  // include micro & omega
      const ALPHANUM = ALPHA + DIGITS;
      const NOSKIP = { noSkip: true };

      function peekc() {
        if (parsePos < parseStr.length)
          return parseStr.charAt(parsePos);
        return null;
      }

      function getc() {
        if (parsePos < parseStr.length) {
          let ch = parseStr.charAt(parsePos);
          parsePos += 1;
          if (parsePos > parseFurthest && parseStr === initialParseStr)
            parseFurthest = parsePos;
          return ch;
        }
        return null;
      }

      function take(match, opts) {
        const backtrack = parsePos;
        if (!opts?.noSkip)
          skipSpaces();
        if (parseStr.charAt(parsePos) === match) {
          parsePos += 1;
          if (parsePos > parseFurthest && parseStr === initialParseStr)
            parseFurthest = parsePos;
          return true;
        }
        parsePos = backtrack;
        return false;
      }

      function skipSpaces() {
        let foundSpace = false;
        let ch = peekc();
        while (ch === " " || ch === "\t") {
          getc();
          ch = peekc();
          foundSpace = true;
        }
        return foundSpace;
      }

      // Numbers of form:
      //    ddd
      //    ddd.
      //    ddd.dd
      //    .ddd

      function parseNum(opts) {
        const backtrack = parsePos;
        let nDigits = 0;
        if (!opts?.noSkip)
          skipSpaces();
        let ch = peekc();
        if (DIGITS.includes(ch) || ch === ".") {
          let val = 0, div = 1;
          while (DIGITS.includes(ch)) {
            val = val*10 + parseInt(ch);
            getc();
            ch = peekc();
            nDigits += 1;
          }
          if (!opts?.intOnly && take('.', NOSKIP)) {
            ch = peekc();
            while (DIGITS.includes(ch)) {
              val = val*10 + parseInt(ch);
              div *= 10;
              getc();
              ch = peekc();
              nDigits += 1;
            }
          }
          const backtrack2 = parsePos;
          if (!opts?.intOnly && take('e', NOSKIP)) {
            take('+', NOSKIP);
            take('-', NOSKIP);
            if (DIGITS.includes(peekc())) {
              // let JavaScript parse the number
              while (DIGITS.includes(peekc()))
                getc();
              let str = parseStr.substring(backtrack, parsePos);
              let val = Number.parseFloat(str);
              if (isNaN(val)) {
                parsePos = backtrack;
                throw `Bad number: ${str}`;
              }
              return val;
            }
          }
          parsePos = backtrack2;
          if (nDigits > 0) {
            if (opts?.preciceDecimal)
              return [ val, div ];
            return val/div;
          }
          parsePos = backtrack;    
        }
        return null;
      }

      // Parse a number or a number followed by fraction or a fraction:
      //    n | word 
      //    n n/n
      //    (n|word)/n
      // -- word must be a dimensionless number, mostly in service of saying "pi/4 radians"

      function parseNumFrac(opts) {
        let val = parseNum(opts);
        if (val === null) {
          let word = parseWord(), sym = word && getSymbol(word);
          if (!sym || sym.type !== 'num' || !Dim.isScalar(sym.dim))
             return null;
          val = sym.val;
          if (opts?.preciceDecimal)
            val = [ val, 1 ];
        }
        const backtrack = parsePos;
        if (take('/', NOSKIP)) {
          let denom = parseNum({ noSkip: true, intOnly: true });
          if (denom === null) {
            parsePos = backtrack;
            return val;
          }
          if (opts?.preciceDecimal) {
            if (denom === 0)  throw "Divide by zero";
            return [ val[0], denom*val[1] ];
          }
          const q = val/denom;
          if (!isFinite(q)) throw "Divide by zero";
          return q;
        }
        let num = parseNum({ intOnly: true });
        if (num === null)
          return val;
        if (take('/'), NOSKIP) {
          let denom = parseNum({ noSkip: true, intOnly: true });
          if (denom !== null) {
            if (opts?.preciceDecimal) {
              if (denom === 0) throw "Divide by zero";
              return [ val[0] + num*val[1]/denom, val[1] ];
            }
            const q = num/denom;
            if (!isFinite(q)) throw "Divide by zero";
            return val + q;
          }
        }
        parsePos = backtrack;
        return val;
      }

      function numVal(val) {
        if (val?.origin)   // collapse afine values
          return val.val + val.origin;
        return val.val;
      }

      // Parse a value, which is either a plain number (n) or a sequesnce of
      // number-fractions (nf) each followed by a unit:
      //    n
      //    [ nf [ '/'? unit ['^' n]? ]+ ]*
          
      function parseValue(opts) {
        const backtrack1 = parsePos;
        let num = 0, dim, origin;
        let lastUnitVal = Number.POSITIVE_INFINITY;
        let uscu = false;   // consider it metric unless we encounter any non-metric unit

        // The idea of lastUnitVal is that units should get progressively smaller.
        // Otherwise, someone could enter 2'3' when they meant 2'3"

        while (true) {  // additive chunks [nf unit unit unit]*
          // chunkVal is [ num, denom ] to try to preserve decimal precision.
          // The idea is tha decimals like "0.1" can't be represented exactly but
          // the units have factors of ten in them so first multiply the unit
          // then divide by the denom so that the value remains a clean integer when possible.
          let chunkVal = parseNumFrac({ ...opts, preciceDecimal: true });
          if (chunkVal === null)
            break;
          let chunkDim = {};
          let gotUnit = false;
          if (take("'")) {
            if (FT >= lastUnitVal) throw "Implausible units";
            lastUnitVal = FT;
            chunkDim.L = 1;
            chunkVal = [ chunkVal[0]*FT, chunkVal[1] ];
            uscu = true;
            gotUnit = true;
          } else if (take('"')) {
            if (IN >= lastUnitVal) throw "Implausible units";
            lastUnitVal = 1;
            chunkDim.L = 1;
            chunkVal = [ chunkVal[0]*IN, chunkVal[1] ];
            uscu = true;
            gotUnit = true;
          } else {
            // system and user-defined units
            while (true) {
              const backtrack2 = parsePos;
              let hasSlash = take('/');
              let word = parseWord({ ...opts, noSkip: hasSlash });
              if (!word) {
                parsePos = backtrack2;
                break;
              }
              const sym = getSymbol(word);
              if (!sym)
                throw new ChattyError(`Unknown unit: "${word}"`);
              if (sym.origin) {
                if (origin)
                  origin += sym.origin;
                else
                  origin = sym.origin;
              }
              if (Dim.isScalar(sym.dim) || !sym.val)
                throw new ChattyError(`Not a unit: "${word}"`);
              let symVal = sym.val;
              if (symVal.val >= lastUnitVal) throw "Implausible units";
              lastUnitVal = sym.val;
              let saveChunkDim = chunkDim;
              if (hasSlash)
                chunkDim = Dim.sub(chunkDim, sym.dim);
              else
                chunkDim = Dim.add(chunkDim, sym.dim);
              if (hasSlash)
                chunkVal = [ chunkVal[0]/symVal, chunkVal[1] ];
              else
                chunkVal = [ chunkVal[0]*symVal, chunkVal[1] ];
              if (sym.uscu)
                uscu = true;
              gotUnit = true;
            }
          }
          if (!gotUnit) {
            dim = undefined;
            parsePos = backtrack1;
            break;
          }
          if (!dim)
            dim = chunkDim;
          else if (!Dim.equal(dim, chunkDim))
            throw new ChattyError("Implausible units");
          num += chunkVal[0] / chunkVal[1];
          if (!isFinite(num)) throw "Divide by zero";
        }
        if (dim)
          return { type: 'num', dim, val: num, origin, uscu };
        parsePos = backtrack1;
        num = parseNum(opts);
        if (num !== null)
          return  {type: 'num', dim: {}, val: num };
        return null;
      }

      // Parse a word

      function parseWord(opts) {
        const backtrack = parsePos;
        if (!opts?.noSkip)
          skipSpaces();
        if (ALPHA.includes(peekc())) {
          let word = getc();
          while (ALPHANUM.includes(peekc()))
            word += getc();
          return word;
        }
        parsePos = backtrack;
        return null;
      }

      // Parse a term, which is either a unary expression, a
      // parenthesized expression, a function call, a value or a word (variable)
      //    '+' term
      //    '-' term
      //    '/' term     -- reciprocal
      //    '(' expr ')'
      //    term [ '(' [ expr [ ',' expr ]* ]? ')' ]+
      //    value
      //    word

      function parseTerm(opts) {
        const backtrack = parsePos;

        // Deal with unary first
        if (take('+')) {
          let val = parseTerm(opts);
          if (val !== null) {
            if (val.type === 'parse')
              return val;
            if (val.type !== 'num') throw new ChattyError("Must be numeric");
            return val;
          }
          parsePos = backtrack;
          return null;
        }
        if (take('-')) {
          let val = parseTerm(opts);
          if (val !== null) {
            if (val.type === 'parse')
              return { type: 'parse', op: 'neg', expr: val };
            if (val.type !== 'num') throw new ChattyError("Must be numeric");
            let resVal = - val.val;
            if (val.origin)   // special negation of afine values: don't nehate the origin value
              resVal += val.origin
            return { type: val.type, dim: val.dim, val: resVal, uscu: val.uscu };
          }
          parsePos = backtrack;
          return null;
        }
        if (take('/')) {
          let val = parseTerm(opts);
          if (val !== null) {
            if (val.type === 'fn') throw new ChattyError("can't divide functions");
            if (val.type === 'parse')
              return { type: 'parse', op: 'recip', expr: val };
            const q = 1/numVal(val);
            if (!isFinite(q)) throw "Divide by zero";
            return { type: val.type, dim: Dim.mul(val.dim, -1), val: q, uscu: val.uscu };
          }
          parsePos = backtrack;
          return null;
        }

        // Now deal with exprs that might or might not be followed by function invocation
        let val = null;
        if (take('(')) {
          let val1 = parseExpr(opts);
          if (val1 && take(')')) {
            val = val1;
          }
        } else {
          if (opts?.noUnits) {
            val = parseNum(opts);
            if (val !== null)
              val = { type: 'num', dim: {}, val: val };
          } else {
            val = parseValue(opts);
          }
          if (val === null) {
            const word = parseWord(opts);
            if (word !== null) {
              let val1 = getSymbol(word);
              skipSpaces();
              // As a special case, a function of no arguments can be used as a constant
              if (peekc() !== '('
                  && val1 instanceof Object && val1.type === 'fn' && val1.params.length === 0)
                val = invokeFunction(val1, []);
              else if (!(val1 instanceof Object && val1.type))
                throw new ChattyError(`Unknown variable: "${word}"`);
              else
                val = val1;
            }
          }
        }
        if (val === null) {
          parsePos = backtrack;
          return null;
        }

        // This loops because a function can return a function
        while (take('(')) {
          const params = [];
          let arg = parseExpr(opts);
          while (arg !== null) {
            params.push(arg);
            if (!take(','))
              break;
            arg = parseExpr(opts);
          }
          if (!take(')')) {
            parsePos = backtrack;
            return null;
          }
          let paramsParse = false;
          for (const p of params)
            if (p.type === 'parse')
               paramsParse = true;
          if (paramsParse || val.type === 'parse')
            val = { type: 'parse', op: 'call', expr: val, params: params };
          else
            val = invokeFunction(val, params);
        }
        return val;
      }

      // Parse an exponentiation expression (right-associative)
      //    term '^' exponentiation
      //    term

      function parseExponentiation(opts) {
        let val = parseTerm(opts);
        if (val === null)
          return null;
        const backtrack = parsePos;
        if (take('^')) {
          let exp = parseExponentiation({ ...opts, noUnits: true });
          if (!exp) {
            parsePos = backtrack;
            return val;
          }
          if (val.type === 'fn' || exp.type === 'fn')
            throw "Cannot exponentiate functions";
          if (val.type === 'parse' || exp.type === 'parse')
            return { type: 'parse', op: 'exp', expr1: val, expr2: exp };
          if (!Dim.isScalar(exp.dim))
            throw "Must exponentiate with a scalar";
          if (!Dim.isScalar(val.dim) && numVal(exp) !== Math.trunc(numVal(exp)))
            throw "Cannot exponentiate non-scalars by non-integers";
          return { type: 'num', dim: Dim.mul(val.dim, exp.val),
            val: Math.pow(numVal(val), numVal(exp)), uscu: val.uscu };
        }
        return val;
      }

      // Parse a multiplicitive expression:
      //    exponentiation [ '*' exponentiation ]*
      //    exponentiation [ '/' exponentiation ]*

      function parseMulExpr(opts) {
        const backtrack = parsePos;
        let val = parseExponentiation(opts);
        if (val === null)
          return null;
        while (true) {
          if (take('*') || take('\u00D7')) {  // '*' or times sign
            let val2 = parseExponentiation(opts);
            if (val2 === null) {
              parsePos = backtrack;
              return null;
            }
            if (val.type === 'fn' || val2.type === 'fn')
              throw "Can't multiply functions";
            if (val.type === 'parse' || val2.type === 'parse')
              val = { type: 'parse', op: '*', expr1: val, expr2: val2 };
            else if (val.type === 'num' && val2.type === 'num')
              val = { type: 'num', dim: Dim.add(val.dim, val2.dim), val: numVal(val) * numVal(val2),
                uscu: val.uscu || val2.uscu };
            else
              throw "Unknown value type";
          } else if (take('/') || take('\u00F7')) { // '/' or divide sign
            let val2 = parseExponentiation(opts);
            if (val2 === null) {
              parsePos = backtrack;
              return null;
            }
            if (val.type === 'fn' || val2.type === 'fn')
              throw "Can't divide functions";
            if (val.type === 'parse' || val2.type === 'parse') {
              val = { type: 'parse', op: '/', expr1: val, expr2: val2 };
            } else if (val.type === 'num' && val2.type === 'num') {
              const q = numVal (val) / numVal(val2);
              if (!isFinite(q)) throw "Divide by zero";
              val = { type: 'num', dim: Dim.sub(val.dim, val2.dim), val: q,
                uscu: val.uscu || val2.uscu };
            } else {
              throw "Unknown value type";
            }
          } else {
            break;
          }
        }
        return val;
      }

      // Parse an (additive) expression:
      //    mulexpr [ '+' mulexpr ]*
      //    mulexpr [ '-' mulexpr ]*

      function parseExpr(opts) {
        const backtrack = parsePos;
        let val = parseMulExpr(opts);
        if (val === null)
          return null;
        while (true) {
          if (take('+')) {
            let val2 = parseMulExpr(opts);
            if (val2 === null) {
              parsePos = backtrack;
              return null;
            }
            if (val.type === 'fn' || val2.type === 'fn')
              throw new ChattyError("Can't add functions");
            if (val.type === 'parse' || val2.type === 'parse') {
              val = { type: 'parse', op: '+', expr1: val, expr2: val2 };
            } else if (numVal(val2) === 0) {
              // special case for adding 0; keep first val
            } else if (numVal(val) === 0) {
              val = val2;  // special case for adding 0; take second val
            } else if (val.type === 'num' && val2.type === 'num') {
              if (Dim.equal(val.dim, val2.dim)) 
                val = { type: 'num', dim: val.dim, val: numVal(val) + numVal(val2),
                  uscu: val.uscu || val2.uscu };
              else
                throw new ChattyError("Cannot add different unit types")
            } else {
              throw "Unknown value type";
            }
          } else if (take('-')) {
            let val2 = parseMulExpr(opts);
            if (val2 === null) {
              parsePos = backtrack;
              return null;
            }
            if (val.type === 'fn' || val2.type === 'fn')
              throw "Can't subtract functions";
            if (val.type === 'parse' || val2.type === 'parse') {
              val = { type: 'parse', op: '-', expr1: val, expr2: val2 };
            } else if (numVal(val2) === 0) {
              // special case for subtracting 0; take first val
            } else if (val.type === 'num' && val2.type === 'num') {
              if (Dim.equal(val.dim, val2.dim))
                val = { type: 'num', dim: val.dim, val: numVal(val) - numVal(val2),
                  uscu: val.uscu && val2.uscu };
              else
                throw new ChattyError("Cannot subtract different unit types")
            }
            else {
              throw "Unknown value type";
            }
          } else {
            break;
          }
        }
        return val;
      }

      // Parse a statement:
      //    expr
      //    expr '|'  word
      //    word '=' expr
      //    word '(' [ word [ ',' word ]* ]? ')' '=' expr

      function parseStatement(opts) {
        const backtrack = parsePos;
        let word = parseWord(opts);
        if (word !== null) {
          if (take('=')) {
            let val = parseExpr(opts);
            if (val) {
              return { ...val, sym: word, defined: true };
            }
          }
          if (take('(')) {
            let params = [];
            let param = parseWord(opts);
            while (param !== null) {
              params.push(param);
              if (!take(','))
                break;
              param = parseWord(opts);
            }
            if (take(')') && take('=')) {
              // make sure the parameters all have different names
              const paramNames = {};
              for (const p of params) {
                if (paramNames[p]) throw `duplicate parameter ${p} in function ${word}`;
                paramNames[p] = true;
              }
              const saveEnv = environment;
              try {
                environment = {};
                for (const p of params)
                  environment[p] = { type: 'parse', sym: p, defined: true };
                skipSpaces();
                const exprStart = parsePos;
                let expr = parseExpr(opts);
                environment = saveEnv;
                if (expr !== null)
                  return { type: 'fn', expr: expr, sym: word, defined: true,
                           params: params, body: parseStr.substr(exprStart) };
               }
               catch (e) {
                 environment = saveEnv;
                 throw e;
               }
             }
           }
           parsePos = backtrack;
        }
        let val = parseExpr();
        if (val && take('|')) {
           let word = parseWord();
           if (word) {
             let leadingTerm = getSymbol(word);
             if (leadingTerm && leadingTerm.type === 'num' && !Dim.isScalar(leadingTerm.dim))
               return { ...val, leadingTerm };
             throw new ChattyError(`Not a unit: ${word}`);
           }
           parsePos = backtrack;
           return null;
        }
        return val;
      }

      //
      // Set up the initial parser state and parse a statement,
      // making sure all the input is consumed.
      //
      function parseInputStatement(stmt, env, opts) {
        parseStr = initialParseStr = stmt;
        parsePos = 0;
        parseFurthest = 0;
        environment = env || {};
        let val = parseStatement(opts);
        skipSpaces();
        if (val === null || peekc()) {
          let rest = parseStr.substr(parseFurthest);
          if (rest.length > 0)
            throw new ChattyError(`Cannot parse beyond "${rest}"`);
          else if (parseStr.trim() !== "")
            throw new ChattyError(`Incomplete input`);
        }
        return val;
      }

      function updateParse(userHitEnter) {
        clearFields();
        try {
          let val = parseInputStatement(document.getElementById('expr').value);
          if (val !== null) {
            if (userHitEnter && val.defined) {
              const sym = val.sym;
              const symVal = getSymbol(sym);
              if (symVal?.reserved) {
                let name = `"${sym}"`;
                if (symVal.desc && symVal.desc !== sym)
                  name = `${name} (${symVal.desc})`;
                throw `Cannot redefine reserved symbol ${name}`;
              }
              val = { ...val };         // copy, because we're about to modify it
              showAssignResult(val);
              delete val.defined;       // removes the flag that forces the definition
              delete val.desc;          // removes description
              delete val.reserved;      // removes "reserved" designation
              userSymbols[sym] = val;
              showUserSymbols();
            } else if (val.type === 'num' && val.uscu && Dim.equal(val.dim, { L: 1 }) && !val.leadingTerm) {
              showFeetInchesResult(numVal(val));
            } else if (val.type === 'num') {
              showResult(val);
            } else if (val.type === 'fn' && !val.defined) {
              showAssignResult(val);
            }
            return;
          } else {
            let rest = parseStr.substr(parseFurthest);
            if (rest.length > 0)
              throw new ChattyError(`Cannot parse beyond "${rest}"`);
            else if (parseStr.trim() !== "")
              throw new ChattyError(`Incomplete input`);
          }
        }
        catch (e) {
          showError(e, { allErrors: userHitEnter });
        }

        // Gray out the result since we can't parse correctly right now
        document.getElementById('results').style.color = '#aaaaaa';  
        document.getElementById('numberResults').style.color = '#aaaaaa';
      }

      function clearFields() {
        for (const field of ['ft', 'inch', 'num', 'times', 'div'])
          document.getElementById(field).value = "";
      }

      function showResult(val) {
        document.getElementById('results').style.display = 'none';
        document.getElementById('numberResults').style.display = '';
        document.getElementById('error').style.display = 'none';
        document.getElementById('numberResults').style.color = '';

        document.getElementById('numberResultsDetail').innerHTML = val2str(val, { html: true, describe: true });
      }

      function escapeHTML(str) {
        return str
          .replace(/&/g, "&amp;")
          .replace(/</g, "&lt;")
          .replace(/>/g, "&gt;")
          .replace(/"/g, "&quot;")
          .replace(/'/g, "&#039;");
      }

      function showUserSymbols() {
        document.getElementById('symdefs');
        let str = "";
        // It seems like sorting is a good idea, but
        // JavaScript keeps entries in definition order and
        // it's nice to list them in the reverse order of definition
        let keys = Object.keys(userSymbols).reverse();
        for (const sym of keys) {
          let symStr = symString(userSymbols[sym], { html: true });
          if (symStr)
            str += `<p class="user-def"><span class="delete-button" onclick="deleteDef('${sym}')"></span>
              ${symStr}</p>`;
        }
        document.getElementById('symdefs').innerHTML = str;
      }

      function deleteDef(sym) {
        delete userSymbols[sym];
        showUserSymbols()
      }

      function symString(val, opts) {
        if (Dim.equal(val.dim, { L: 1 }) && !opts?.saveMode) {
          let [ftStr, inStr, delta] = unitsToUSStringReps(numVal(val));
          let str = `${val.sym} = ${ftStr}${delta}`;
          if (opts?.html)
            return escapeHTML(str);
          return str;
        }
        if (val.type === 'num') {
          if (opts?.html)
            return `${escapeHTML(val.sym)} = ${val2str(val, opts)}`;
          if (opts?.html)
            return escapeHTML(str);
          return escapeHTML(`${val.sym} = ${val2str(val, opts)}`);
        }
        if (val.type === 'fn') {
          let str = `${val.sym}(${val.params.join(", ")}) = ${val.body}`;
          if (opts?.html)
            return escapeHTML(str);
          return str;
        }
        return undefined;
      }

      function showAssignResult(val) {
        let str = symString(val, { html: true });
        if (!str)
          return;
        document.getElementById('results').style.display = 'none';
        document.getElementById('numberResults').style.display = '';
        document.getElementById('error').style.display = 'none';
        document.getElementById('numberResults').style.color = '';
        document.getElementById('numberResultsDetail').innerHTML = str;
      }

      function showFeetInchesResult(totalUnits, opts) {

        document.getElementById('results').style.display = '';
        document.getElementById('numberResults').style.display = 'none';
        document.getElementById('error').style.display = 'none';
        document.getElementById('results').style.color = '';

        document.getElementById('resultIn').textContent = val2str(totalUnits/IN);
        document.getElementById('resultFt').textContent = val2str(totalUnits/FT);

        let [ftStr, inStr, delta] = unitsToUSStringReps(totalUnits);
        document.getElementById('resultFtDetail').textContent = ftStr + delta;
        if (opts?.updateExpr)
          document.getElementById('expr').value = ftStr + delta;

        document.getElementById('resultInDetail').textContent = inStr + delta;

        // show metric for good measure
        document.getElementById('resultMeters').textContent =
          val2str(totalUnits/M);
        document.getElementById('resultMetersMetricFeet').textContent =
          val2str((totalUnits/M)/(2.54/2.50));
      }

      function unitsToUSStringReps(totalUnits) {
        let totalInches = totalUnits/IN;
        let minus = "";
        if (totalInches < 0) {
          totalInches = -totalInches;
          minus = "-";
        }

        // Recover feet and inches from from result
        // (round to nearest 1/denom)
        let denom = 32;
        let inches =  Math.trunc(totalInches*denom + 0.5)/denom;
        let ft = Math.trunc(inches/12);
        inches = inches - ft*12;
        let frac = inches - Math.trunc(inches);
        inches = Math.trunc(inches);
        let num = Math.trunc(frac*denom);
        while (denom > 2 && num%2 === 0) {  // reduce fraction
          denom = denom/2;
          num = num/2;
        }

        // format that string
        let ftStr = minus, sp = "";
        if (ft !== 0 || (inches === 0 && num === 0)) {
          ftStr += ft + "'";
          sp = " ";
        }
        if (inches !== 0) {
          ftStr += sp + inches;
          sp = " ";
        }
        if (num !== 0)
          ftStr += `${sp}${num}/${denom}`;
        if (inches !== 0 || num !== 0)
           ftStr += '"';
        let delta = totalInches - (ft*12 + inches + num/denom);
        if (Math.abs(delta) < EPSILON) {
          delta = "";
        } else {
          if (delta < 0)
            delta = ` - ${val2str(-delta)}"`;
          else
            delta = ` + ${val2str(delta)}"`;
        }
 
        // format inches
        let inStr = minus;
        sp = "";
        inches = ft*12 + inches;
        if (inches !== 0 || num === 0) {
          inStr += inches;
          sp = " ";
        }
        if (num !== 0)
          inStr += `${sp}${num}/${denom}`;
        inStr += '"';
        return [ftStr, inStr, delta];
      }

      function showHelp(id) {
        // hide all help
        let elts = document.querySelectorAll('div.help');
        for (let e of elts)
          e.style.display = ''; // back to inherited 'none'
        let helpElement = document.getElementById(id);
        if (helpElement) {
          helpElement.style.display = "block"; // inherits 'none' from "help" class
          for (let child of helpElement.children)
            if (child.tagName === 'DIV')
              child.scroll(0, 0);
        }
      }

      const GUID = "ad1f9c32-ed69-457d-89a0-f966c81424bd";
      const LOCAL_STORAGE_KEY = "UnitsCalculator-" + GUID;
      const MAJOR = 1, MINOR = 0, PATCH = 0;

      function loadUserSymbols() {
        const localStorage = window.localStorage;
        if (!localStorage)
          return false;
        let json = localStorage.getItem(LOCAL_STORAGE_KEY);
        if (!json)
          return false;
        let wad = JSON.parse(json);
        if (!wad || !wad.major || wad.major > MAJOR)
          return false;
        if (!wad.defs)
          return false;
        for (const def of wad.defs) {
          try {
            let val = parseInputStatement(def);
            skipSpaces();
            if (val !== null && !peekc()) { // nothing left over at the end
              let sym = val.sym;
              if (systemSymbols[sym]?.reserved)
                next;
              delete val.defined;
              userSymbols[sym] = val;
            }
          }
          catch (e) {
          }
        }
        showUserSymbols();
        return true;
      }

      function saveUserSymbols() {
        const localStorage = window.localStorage;
        if (!localStorage)
          return false;
        const wad = {
          major: MAJOR, minor: MINOR, patch: PATCH, defs: []
        };
        // We rely on the fact that objects are enumerated in the order
        // items were added. Otherwise, function definitions might fail
        // due to their variable references being unsatisfied.
        for (const sym in userSymbols) {
          if (userSymbols[sym].native || userSymbols[sym].origin)
            continue;  // can't save these types now
          let symStr = symString(userSymbols[sym], { saveMode: true });
          if (symStr) {
            wad.defs.push(symStr);
            if (logLevel > 0)
              console.log(`Saving: ${symStr}`);
          }
        }
        let json = JSON.stringify(wad);
        try {
          localStorage.setItem(LOCAL_STORAGE_KEY, json);
          return true;
        }
        catch (e) {
        }
        return false;
      }

      function addExampleStuffs() {
        for (const help of document.querySelectorAll("div.help")) {
          help.addEventListener("click", function(event) {
            let element = event.target;
            while (element) {
              let styles = window.getComputedStyle(element);
              let action = styles.getPropertyValue("--click-action");
              if (action.trim() === "stuff-text") {
                let text = event.target.textContent.trim();
                // special handling for units that have offsets
                let sym = getSymbol(text);
                if (sym?.origin)
                  text = "0 " + text;
                document.getElementById('expr').value = text.trim();
                updateParse(true);
                return;
              }
              element = element.parentElement;
            }
          });
        }
      }

      function toggleLegacyMode(legacy) {
        const attr = 'data-presentation-mode';
        if (legacy || !document.body.getAttribute(attr))
          document.body.setAttribute(attr, 'legacy');
        else
          document.body.removeAttribute(attr);
      }

      if (window.location.href.match(/inch[^/]*$/i))
        toggleLegacyMode(true);
      document.body.setAttribute('data-protocol', window.location.protocol);

      function addBuiltinSymbolsHelp() {
        let html = "";
        for (const [name, sym] of Object.entries(systemSymbols)) {
          if (sym.type !== 'num' || sym.altOf)
            continue;
          let desc = sym.desc ?? name;
          if (sym.reserved)
            desc += " <i>(reserved)</i>";
          html += `<tr><td>${name}<td>/${name}<td>${desc}`;
        }
        document.getElementById('builtin-symbols').innerHTML = html;
      }

      window.addEventListener('load', function onLoad(evt) {
        try { loadUserSymbols(); } // inconvenient to crash while loading
        catch (e) {}
        updateResult();
        addExampleStuffs();
        addBuiltinSymbolsHelp();
      });

      window.addEventListener("beforeunload", function(evt) {
        saveUserSymbols();
      });

      document.addEventListener("keydown", function(evt) {
        evt = evt || window.event;
        if (evt.key === "Escape" || evt.key === "Esc" || evt.keyCode === 27)
          showHelp();
      });
   </script>
  </body>
</html>