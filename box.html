<body style="font: 100% caption, sans-serif">
  <style>
    /*
     * You could declare these programmatically using CSS.registerProperty,
     * but since property names aren't namespaced it's better to let the user do it.
     * FWIW, this also lets the user decide the initial-value.
     */
    @property --box-color { syntax: "<color>"; inherits: false; initial-value: transparent; }
    @property --box-radius { syntax: "<number>"; inherits: false; initial-value: 20; }
    @property --x-size { syntax: "<number>"; inherits: false; initial-value: 90; }
    @property --x-thick { syntax: "<number>"; inherits: false; initial-value: 30; }
    @property --x-cap { syntax: "<number>"; inherits: false; initial-value: 7; }

    close-button.bluebox {
      color: white;
      vertical-align: -20%;
      --box-color: blue;
      --x-size: 75;
    }

    close-button.delete-text {
      color: white;
      --box-color: #8e8d92;
      --box-radius: 50;
      --x-size: 50;
    }

    close-button.transition {
      font-size: 3em;
      color: white;
      --box-color: #8e8d92;
      --box-radius: 50;
      --x-size: 50;
      --x-thick: 20;
      cursor: pointer;
      transition: 2s;
      transition-property: font-size, color, --box-color, --box-radius, --x-size, --x-thick, --x-cap;
    }
    close-button.transition:hover {
      vertical-align: -20%;
      font-size: 5em;
      color: black;
      --box-color: red;
      --box-radius: 10;
      --x-size: 80;
      --x-cap: 0;
      --x-thick: 40;
    }

    close-button.animation {
      animation-duration: 2s;
      animation-name: allprops;
      animation-iteration-count: infinite;
      animation-direction: alternate;
    }
    @keyframes allprops {
      from {
        font-size: 3em;
        color: white;
        --box-color: #8e8d92;
        --box-radius: 50;
        --x-size: 50;
        --x-thick: 20;
      }
      to {
        font-size: 5em;
        color: black;
        --box-color: red;
        --box-radius: 10;
        --x-size: 80;
        --x-cap: 0;
        --x-thick: 40;
      }
    }
  </style>
  <canvas id="canvas1" width="200" height="200">What?</canvas>
  <canvas id="canvas2" width="200" height="200">What?</canvas>
  <canvas id="canvas3" width="200" height="200">What?</canvas>
  <canvas id="canvas4" width="200" height="200">What?</canvas>
  <p>
    <close-button></close-button> Text
  <p>
    <close-button class="transition"></close-button> Transition
  <p>
    <close-button class="animation"></close-button> Animation
  <p style="font-size: 2em">
    <close-button class="bluebox"></close-button> Text
    <close-button class="bluebox"></close-button> Text
    <close-button class="bluebox"></close-button> Text
  <p>
    <close-button class="delete-text"></close-button> Text
    <close-button class="delete-text"></close-button> Text
    <close-button class="delete-text"></close-button> Text
  <script>
      function drawCloseButtonOnCanvas(canvasName, opts) {
        const canvas = document.getElementById(canvasName);
        const ctx = canvas.getContext('2d');
        ctx.save();
        ctx.fillStyle = '#eee';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.restore();
        drawCloseButton(ctx, canvas.width, canvas.height, opts);
      }
      drawCloseButtonOnCanvas('canvas1');
      drawCloseButtonOnCanvas('canvas2', { boxColor: '#f88' });
      drawCloseButtonOnCanvas('canvas3', { boxColor: '#f88', color: 'gray' });
      drawCloseButtonOnCanvas('canvas4', { xCap: 0 });

      //
      // Custom close button element
      //   There's no good way to make a close button using fonts,
      //   so it has come to this.
      //
      function drawCloseButton(ctx, width, height, opts = {}) {
        function pf(s) { // like parseFloat, but returns undefined for non-numbers
          let res = parseFloat(s);
          if (isFinite(res))
            return res;
          return undefined;
        }
        let color = opts.color || 'black';
        let boxColor = opts.boxColor;
        if (boxColor === 'rgba(0, 0, 0, 0)' || boxColor === 'rgba(0,0,0,0)')
          boxColor = '';
        let r = pf(opts.boxRadius) ?? 20;
        let ll = (pf(opts.xSize) ?? (boxColor ? 80 : 100)) / 2;
        let tt = (pf(opts.xThick) ?? ll/2)/2;
        let cc = pf(opts.xCap) ?? tt/2;
        ll = ll - tt - cc/2;
        let magic = 0.551915024494; // https://spencermortensen.com/articles/bezier-circle/
        let m = magic * cc;

        ctx.save();
        // scale to a 100x100 coord system with the origin in the center
        // The "-1" is to keep a pixel from being sheered off the bottom and right edges.
        ctx.scale((width-1)/100, (height-1)/100);
        ctx.translate(50, 50);
        if (boxColor) { // "transparent"
          let b = 50;
          ctx.fillStyle = boxColor;
          ctx.beginPath();
          ctx.moveTo(-b+r, -b);
          ctx.lineTo(b-r, -b);
          ctx.arcTo(b, -b, b, b+r, r);
          ctx.lineTo(b, b-r);
          ctx.arcTo(b, b, b-r, b, r);
          ctx.lineTo(-b+r, b);
          ctx.arcTo(-b, b, -b, b-r, r);
          ctx.lineTo(-b, -b+r);
          ctx.arcTo(-b, -b, -b+r, -b, r);
          ctx.closePath();
          ctx.fill();
        }
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.moveTo(tt, 0);
        for (let i = 0; i < 4; ++i) {
          ctx.lineTo(tt+ll, ll);
          let mid = ll + tt/2 + cc
          ctx.bezierCurveTo(tt+ll+m, ll+m, mid+m, mid-m, mid, mid);
          ctx.bezierCurveTo(mid-m, mid+m, ll+m, tt+ll+m, ll, tt+ll);
          // Arcs are not as pretty
          // ctx.arcTo(t+l+c, l+c, mid, mid, c);
          // ctx.arcTo(l+c, t+l+c, l, t+l, c);
          ctx.lineTo(0, tt);
          ctx.rotate(Math.PI/2);
        }
        ctx.closePath();
        ctx.fill();
        ctx.restore();
      }

      class MRUCache {
        constructor(maxEntries = 20) {
          this.maxEntries = maxEntries;
          this._cache = new Map();
          this._backCache = new Map();
        }
        get(signature, fn) {
          let val = this._cache.get(signature);
          if (!val) {
            val = this._backCache.get(signature);
            if (val)  // promote item from backup cache to main cache
              this._cache.set(signature, val);
            if (!val && fn) {
              val = fn(signature);
              if (val !== undefined)
                this.set(signature, fn(signature));
            }
          }
          return val;
        }
        set(signature, val) {
          if (this._cache.size >= this.maxEntries) {
            // console.info("cache evicting");
            let tmp = this._backCache;
            this._backCache = this._cache;
            this._cache = tmp;
            this._cache.clear(); 
          }
          this._cache.set(signature, val);
        }
      }

      class CloseButtonElement extends HTMLElement {
        constructor() {
          super();
          let root = this.attachShadow({ mode: 'open' });
          this._canvas = document.createElement('canvas');
          this._signature = undefined;
          root.appendChild(this._canvas);
          // Seems you have to register all of these.
          // It would be better if there were just one event called
          // when you should update. If there is, I haven't seen it.
          this.ontransitionstart = event => this.transitionStart();
          this.ontransitionend = event => this.transitionEnd();
          this.ontransitioncancel = event => this.transitionEnd();
          this.onanimationstart = event => this.transitionStart();
          this.onanimationend = event => this.transitionEnd();
          this.ontransitioncancel = event => this.transitionEnd();
        }

        connectedCallback() {
          this.render();
        }

        disconnectedCallback() {
          clearInterval(this._intervalTimer);
        }

        transitionStart() {
          this._transitionRenders = 0;
          this._intervalTimer = setInterval(() => {
            ++this._transitionRenders;
            this.render();
          }, 50);  // 20 times per second
        }

        transitionEnd() {
          // console.info(`transition renders ${this._transitionRenders}`);
          this._transitionRenders = 0;
          clearInterval(this._intervalTimer);
          this.render();
        }

        static cache = new MRUCache(100);

        render() {
          let style = getComputedStyle(this);
          let size = 1.2 * parseFloat(style.fontSize);
          let color = style.getPropertyValue('color'.trim());
          let xSize = style.getPropertyValue('--x-size').trim();
          let xThick = style.getPropertyValue('--x-thick').trim();
          let xCap = style.getPropertyValue('--x-cap').trim();
          let boxColor = style.getPropertyValue('--box-color').trim();
          let boxRadius = style.getPropertyValue('--box-radius').trim();
          let opts = { size, color, xSize, xThick, xCap, boxColor, boxRadius };
          let signature = Object.values(opts).join('/');
          if (this._signature !== signature) {
            let canvas = CloseButtonElement.cache.get(signature, () => {
              let canvas = document.createElement('canvas');
              canvas.setAttribute('width', size);
              canvas.setAttribute('height', size);
              const ctx = canvas.getContext('2d');
              drawCloseButton(ctx, size, size, opts);
              return canvas;
            });
            this._canvas.setAttribute('width', size);
            this._canvas.setAttribute('height', size);
            const ctx = this._canvas.getContext('2d');
            ctx.drawImage(canvas, 0, 0);
            this._signature = signature;
          }
        }
      };
      customElements.define('close-button', CloseButtonElement);
  </script>
</body>