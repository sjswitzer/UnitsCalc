<!--
  Copyright 2021 Stan Switzer

    This work is licensed under a Creative Commons Attribution-ShareAlike
    4.0 International License. https://creativecommons.org/licenses/by-sa/4.0/

  Synopsis:

    A simple tool for doing calculations with US customary units
    of length.
-->
<html>
  <head>
    <title>Feet & Inch Calculator</title>
    <base target="_blank"> <!-- all links open in a new tab/page -->
    <style type="text/css">
      body {
        padding: 4px 12px;
        box-sizing: border-box;
        margin: 0px 8px;
        font-family: caption, sans-serif;
        font-size: 12pt;
        background-color: #f8f8f8;
      }

      /* Spiff up input fields */
      input[type="text"] {
        font-size: 13pt;
        border-radius: 5px;
        padding: 1px 4px;
      }

      /*
       * Layout containers
       */
      div.layout-column {
        display: flex;
        flex-flow: column nowrap;
      }
      div.layout-column > div {
        margin: 4px 0px;
      }
      body > div.layout-column {
        height: 100%;
      }
      div.layout-row {
        display: flex;
        flex-flow: row nowrap;
        flex: 0 0 auto;
      }
      div.expands {
        /* https://geon.github.io/programming/2016/02/24/flexbox-full-page-web-app-layout */
        flex: 1 1 auto;
        overflow: hidden;
      }
      div.shrink-wrap {
        width: min-content;
      }
      div.force-width {
        width: max-content;
      }

      /*
       * Initially-hidden help content.
       * Help contains a <span class="close-button"> for a close button
       * and a <div> for help content which is made scrollable.
       */
      div.help {
        padding: 0px 4px 0px 20px;
        background-color: #e8e8e8;
        position: absolute;
        display: none;
        top: 10%;
        left: 25%;
        right: 16px;
        bottom: 16px;
        border: 2px solid black;
      }
      div.help > span.close-button {
        color: #888888;
        font-weight: bold;
        float: right;
        font-size: 40px;
        cursor: pointer;
        transition: 0.3s;
      }
      div.help > span.close-button:before {
        content: "\d7"; /* Unicode times character */
      }
      div.help > span.close-button:hover {
        transform: scale(1.25);
        color: black;
      }
      div.help > span.close-button:active {
        transform: scale(1.5);
      }
      div.help > div {
        overflow-y: auto;
        height: 100%;
      }
      /* styling for help content */
      div.help td, div.help th {
        padding: 0em .15em;
        vertical-align: top;
        text-align: left;
      }
      div.help ul {
        padding-left: 1.25em;
      }
      div.help ul > li {
        margin: .5em;
      }
      div.help code {
        font-weight: bold;
      } 
      div.help code.abstract {
        font-style: italic;
      }
      div.help table.example tr td:first-child {
        width: 7em;
      }
      div.help table.example {
        margin-left: 1em;
      }
      /* Testing affordance; example text can be stuffed into the expr box */
      div.help table.stuff.example tr td:first-child:hover, div.help code:hover {
        cursor: pointer;
        color: #0000dd;
        text-decoration: underline;
        --click-action: stuff-text
      }

      /*
       * Makes a <span> into a "button"
       */
      span.button {
        display: inline-block;
        cursor: pointer;
        padding: 2px 8px;
        background: #4444ff;
        border-radius: 5px;
        color: white;
        transition: 0.3s;
      }
      span.button:hover {
        background: #0000dd;
        /* transform: scale(1.15); */
      }
      span.button:active {
        background: #0000cc;
        /* transform: scale(1.3); */
      }

      /* Looks like a link but is actually a "button" */
      span.linklike {
        color: #0000dd;
        cursor: pointer;
        text-decoration: underline;
      }

      /*
       * Animates the delete button for variable and function definitions
       */
      p.user-def {
        margin: .25em 0em;
      }
      p.user-def > span.delete-button:hover {
        background: #ff3333;
        /* transform: scale(1.15); */
      }
      p.user-def > span.delete-button:active {
        background: #ff0000;
        /* transform: scale(1.3); */
      }
      p.user-def > span.delete-button {
        display: inline-block; /* so that transform works */
        cursor: pointer;
        padding: 0em .25em;
        background: #ff7777;
        font-weight: bold;
        border-radius: 5px;
        color: white;
        transition: 0.1s;     
        visibility: hidden;
      }
      p.user-def > span.delete-button:before {
        content: "\d7"; /* Unicode times character */
        /*
         * What follows is a fudge to raise the baseline slightly;
         * "times" is apparently designed to match lower-case characters.
         */
        position: relative;
        top: -0.06em;
      }
      p.user-def:hover > span.delete-button {
        visibility: visible;
      }

      /*
       * User symbol defs take the remaining space and scroll
       */
      div.sym-defs {
        flex: 1 1 auto;
        overflow: auto;
        max-height:100%;
      }

      /* The results box */
      div.results {
        border: 2px solid;
        margin: 12px 0px;
        padding: 0px 12px;
        border-radius: 5px;
      }
    </style>
  </head>
  <body onload="onLoad()">
    <div class="layout-column shrink-wrap">
      <div class="force-width">
        <input type="text" style="text-align: right;"
          oninput="updateResult()" size="4" id="ft" value="5"> feet &nbsp;
        <input type="text" style="text-align: right;"
          oninput="updateResult()" size="2" id="inch" value="">
        <sup>
          <input type="text" style="text-align: right;"
            oninput="updateResult()" size="2" align="right" id="num" value="">
        </sup>/<sub>
          <input type="text" oninput="updateResult()" size="2" id="denom" value="8">
        </sub> inches
        &nbsp;&nbsp; times
        <input type="text" oninput="updateResult()" size="3" id="times" value="">
        &nbsp; divided by
        <input type="text" oninput="updateResult()" size="3" id="div" value="">
      </div>
      <div class="layout-row">
        <div class="expands">
          <input style="width: 100%;" type="text" spellcheck="false" id="expr" value=""
            oninput="updateParse()" onchange="updateParse(true)">
        </div>
        <span class="button" style="margin-left: .25em; font-size: 1.125em"
          onclick="showHelp('help-expr')">?</span>
      </div>
      <div class="results">
        <p id="results">
          <span id="resultFt"></span> feet = <span id="resultFtDetail"></span>
          <br>
          <span id="resultIn"></span> inches = <span id="resultInDetail"></span>
          <br>
          <span id="resultMeters"></span> meters
          <br>
          <span id="resultMetersMetricFeet"></span> meters (assuming "metric feet")
        </p>
        <p id="numberResults">
          <span id="numberResultsDetail"></span>
        </p>
        <p id="error" style="color: red"></p>
      </div>
      <div class="layout-row expands">
        <div class="sym-defs" id="symdefs"></div>
        <div><span class="button" onclick="showHelp('help-tips')">Help</span></div>
      </div>
    </div>
    <div class="help" id="help-tips">
      <span class="close-button" onclick="showHelp()"></span>
      <div>
        <h2> Help </h2>
        <p> Some quick tips to get you started:
        <ul>
          <li> Input boxes can be left empty when not relevent.
          <li> A value like five and a half feet can be entered as 5.5 feet or as 5 feet 6 inches.
          <li> A value like six and a quarter inches can be entered as 6.25 inches or
               as 6 inches and 1/4.
          <li> A "metric foot" is a convention used by the construction industry in metric
               countries where a foot is taken to be exactly 30cm instead of 30.48cm. It's an
               <a href="https://en.wikipedia.org/wiki/ISO_2848#Metric_foot">
                 international standard</a>!
          <li> You can type a fairly general expression into the text box. Click the
               <span class="button" onclick="showHelp('help-expr')">?</span> button
               for more information.
        </ul>
      </div>
    </div>
    <div class="help" id="help-expr">
      <span class="close-button" onclick="showHelp()"></span> 
      <div>
        <h2> Expressions </h2>
        <p> Expressions can contain numbers, units and the operators
            <code>+</code> <code>-</code> <code>*</code> <code>/</code>
            and <code>^</code> (exponentiation).
            Multiplication and division are performed before addition and subtraction, and
            parenthesis can be used for grouping. Spaces are generally optional.
        <p> Units include:
            <code>ft</code> <code>'</code> <code>in</code> <code>"</code> 
            <code>m</code> and <code>cm</code>.
        <p> As you type, the expression might be momentarily unparsable, e.g.,
            "<code>3'+</code>", until you finish typing. 
            The results box will be grayed out while that happens.
            It would be too noisy to alert each of these errors, but if you don't 
            know why it's grayed out, you can hit enter to see an error message.
        </p>
        <table class="stuff example">
          <tr>
            <th> Example
            <th> Description
          <tr>
            <td> 5' 6"
            <td> An ordinary distance
          <tr>
            <td> 5' 6 3/8" / 3
            <td> Divide 5 feet 6 and 3/8 inches by 3
          <tr>
            <td> 5 1/2' - 8"
            <td> Subtracts lengths
          <tr>
            <td> 5.5'
            <td> You can use decimal values instead of fractions
          <tr>
            <td> 3/4"
            <td> You can use just a fraction
          <tr>
            <td> (5'6" + 7') / 2
            <td> The average of 5'6" and 7'
          <tr>
            <td> 5'10 3/8" * 3/4
            <td> 3/4 of 5' 10 3/8"
          <tr>
            <td> 12' / 6"
            <td> The ratio of 12' and 6" (result is 24)
          <tr>
            <td> 1 + 2 * 3
            <td> Ordinary math (note order of operations; result is 7)
          <tr>
            <td> (1 + 2) * 3
            <td> Result is 9
          <tr>
            <td> 1m - 2cm
            <td> One meter minus two centimeters
         <tr>
            <td> ft
            <td> A foot
          <tr>
            <td> ft * 8
            <td> 8 feet; notice that named units are simply variables that have units
          <tr>
            <td> 5' 6" * pi
            <td> Circumference of a 5' 6" diameter circle
          <tr>
            <td> hyp(3', 4')
            <td> Hypotenuse of a right triangle with sides 3' and 4' (result is 5')
          <tr>
            <td> 1/4 mi2 / acre
            <td> The number of acres in a quarter of a square mile
        </table>
        <h2> Terms </h2>
        <p> Expressions are built up out of <i>terms</i> which are either
          <ul>
            <li> A plain number such as <code>12</code>, <code>7.</code>,
                 <code>3.14</code>, <code>.15</code>, etc.
            <li> A variable name, such as <code>pi</code>
            <li> A <i>length</i> which can be a number, a fraction, or a number
                 and a fraction followed buy a <i>unit</i>
            <li> Any sequence of the the previous length-unit combinations as long as
                 the units are of descending size
          </ul>
        <h3> Units </h3>
        <p> Units are either the notations <code>'</code> and <code>"</code> for
            feet and inches or these named units:
        </p>
        <table class="stuff example">
          <tr>
            <th> Unit
            <th> Description
          <tr>
            <td> in
            <td> Inchs
          <tr>
            <td> ft
            <td> Feet
          <tr>
            <td> mi
            <td> Miles
          <tr>
            <td> acre
            <td> Acres
          <tr>
            <td> m
            <td> Meters
          <tr>
            <td> cm
            <td> Centimeters
          <tr>
            <td> mm
            <td> Millimeters
          <tr>
            <td> hectare
            <td> A hectare, or 100m x 100m
        </table>
        <p> In fact, any <i>variable</i> you define with a unit can be used as
            a unit itself.
            For example, if you enter <code>yd = 3'</code>, you can then use
            expressions like <code>3yd 5 1/2"</code>.
        <p> A unit can be immediately followed (without spaces) by a number which is
            the power of that unit. For instance, <code>3 yd2</code> is three square yards
            (27 square feet)
            and <code>2 ft3</code> is two cubic feet. if a unit specifier is immediately
            preceded by a <code>/</code> (without spaces), it is an inverse unit.
            For instance, <code>60 /ft2</code> means 60 per square foot.
            <code>144/ft2</code> means 144 per square foot or, equivalently, 1 per square inch
            (which is how it will display). What per square foot? Anything. Think "ducks" and
            you'll be on the right track.
        <p> Units must be specified in descending order.
            You can use <code>12'3"</code> but you can't use <code>12"3'</code>.
            This is to prevent accidentally typing <code>12'3'</code> when you really
            meant <code>12'3"</code>.
            You can type nonsense like <code>3 1/2m 3.5"</code> if you want, but you won't
            do it by accident.
        <p> Beware that spaces can occasionally make a big difference.
            <code>1/2 in</code> or <code>1/2in</code> means half an inch,
            but <code>1 / 2 in</code> or even
            <code>1/ 2 in</code> means one over 2 inches. Just avoid putting spaces around
            the slash in a fractional unit and you'll be fine.
        <h2> Variables </h2>
        <p> Define variables by typing <code class="abstract">name = expression</code>
            then hitting "enter."
            For instance, <code>frontage = 45'4 3/4"</code>. You can then use those values
            in later expressions, e.g. <code>frontage/3</code>.
            Amusingly, perhaps, because <code>frontage</code> is a length, it can also be
            used as a unit: <code>1/3 frontage</code> or <code>1/3frontage</code>.
        <p> The variables <code>ft</code>, <code>in</code>, <code>m</code>, and <code>cm</code>
            are predefined for use as values or as units. The variable <code>pi</code> is
            predefined in case you care about circles. Predefined variables cannot be changed.
        <h2> Functions </h2>
        <p> Define functions to automate routine calculations by typing
            <code class="abstract">name(param,param,&hellip;) = expression</code>
            then hitting "enter." For instance, you can define a function to average to numbers
            or lengths: <code>average(x,y) = (x+y)/2</code> (but the predefined function
            <code>mean(&hellip;)</code> already does that, so&hellip;).
        <p> Function bodies can use any of their parameters (<i>of course</i>) and variables
            that have already been defined. As a special case, a function with no parameters
            can be used as a "dynamic variable." That is, assuming variables <code>a</code>
            and <code>b</code> are already defined, the function
            <code>c() = a + b</code> can be invoked as <code>c()</code> or <code>c</code>,
            and in either case gives you the current value of <code>a + b</code>.
        <h3> Built-In Functions </h3>
        <table class="example">
          <tr>
            <th> Function
            <th> Description
          <tr>
            <td> mean(x,y,&hellip;) 
            <td> The average of a set of numbers or lengths
          <tr>
            <td> hyp(x,y,&hellip;) 
            <td> The hypotenuse of a triangle or, more usefully, the diagonal of a rectangle
          <tr>
            <td> sqrt(x) 
            <td> Square root
        </table>
        <h2> Saved State </h2>
        <p> User-defined variables and functions are saved between sessions in local
            storage. In case you run into a problem with that, you can
            <span class="linklike" onclick="clearLocalStorage()">clear</span>
            local storage.
        <h2> Odds And Ends </h2>
        <p> <span class="linklike" onclick="showHelp('help-boring')">Boring details</span>
            if you're interested.
      </div>
    </div>
    <div class="help" id="help-boring">
      <span class="close-button" onclick="showHelp()"></span>
      <div>
        <h2> Boring Details </h2>
        <p> This program started out as a quick and dirty tool to easily divide
            lengths given in feet and inches into equal parts, a common task
            in the construction industry and quite tedious to work out by hand.
            The vestiges of that are seen in the top line of the current
            user interface.
        <p> But I started to think of it as a <i>calculator</i> and wondered
            if it could be generalized to do arbitrary math with lengths. The result
            is what you see here. It's not clear how useful any of that functionality
            is but it was a good excuse to tinker.
        <p> One could easily imagine extending it further.
            It's possible to add two lengths,
            resulting in another length, or to multiply or divide a length by a number.
            But you can't add a length and a number.
            You can divide a length by a length to get a number (the ratio of lenghts).
            Can you multiply two lengths? Yes, but the result is an <i>area</i>.
        <p> This line of thinking leads to
            <a href="https://en.wikipedia.org/wiki/Dimensional_analysis">dimensional analysis</a>,
            and there are already some very good programs out there for that including the
            legendary
            <a href="https://linux.die.net/man/1/units">Unix "units" command</a>.
            Hell, <a href="https://www.google.com/search?q=12+acres+%2F+100+feet">
            Google will do it for you</a> if you ask it nicely. This program
            does a limited amount of dimensional analysis in lenghts, areas, volumes, etc.
        <p> The main distinction of this tool is that it deals naturally with notations
            typically used with feet and inches. But, <i>sigh</i>,
            <a href="https://www.google.com/search?q=5%27+6+3%2F8%22+%2F+3">
            Google will do that for you too</a>.
        <p> Oh well, it was a good excuse to spiff up my HTML, CSS, and JavaScript skills.
            Not a bad weekend project.
        <p> Copyright &copy; 2021, Stan Switzer
        <div style="float: left; margin: 0em .5em 4.5em 0em">
          <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">
            <img alt="Creative Commons License" style="border-width:0"
              src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png">
          </a>
        </div>
        <p> This work is licensed under a
          <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">
            Creative Commons Attribution-ShareAlike 4.0 International License
          </a>.
        <br> Find source on
          <a href="https://gist.github.com/sjswitzer/77288511a213dd0d973d99a941ac909e">GitHub</a>
      </div>
    </div>
    <script type="text/javascript">
      "use strict";

      // A curious thing worth noting: It turns out that fractions of the form
      // "n / power-of-2" are precicely the values that can be represented exactly
      // in floating point arithmetic and also the conventional way of expressing
      // fractional inches. So doing all arithmetic in units of inches means that
      // calculations can be exact when exact results are possible.
      //
      // It later occurred to me that doing calculations in metric units of a
      // hundredth of a centimeter or less would lead to exact results for both systems
      // most often. The largest SI unit that would serve is the micrometer, μm or,
      // in ASCII, um. So currently, the basic unit of length is the "um", and in the
      // code the symbol "umExp" refers to the exponent of the micrometer unit.

      const UM = 1;
      const MM = 1000*UM;
      const CM = 10*MM;
      const M  = 1000*MM;
      const KM = 1000*M;
      const IN = 25400*UM;
      const FT = 12*IN;

      // Errors that are too chatty to show while typing.
      //   (Error will be shown if the user hits "enter.")
      class ChattyError extends Error {
        constructor(msg) {
          super();
          this.message = msg;
        }
      }

      //
      // Simple interface for common operations
      //

      function getField(name, def) {
        document.getElementById(name).style.color = '';
        let val = document.getElementById(name).value.trim();
        if (val === "") return def;
        val = parseFloat(val);
        if (isNaN(val) || (val === 0 && def !== 0))
          document.getElementById(name).style.color = 'red';
        return val;
      }

      const DIGITS_PRECISION = 10, EPSILON = Math.pow(10, -DIGITS_PRECISION);

      function val2str(val, opts) {
        let unitsStr = "";
        if (val.val !== undefined) {
          let umExp = val.umExp;
          let metric = val.metric;
          val = val.val;
          if (umExp !== undefined && umExp !== 0) {
            // Find best unit to express the value in
            let displayExp = umExp;
            let units = ['in', 'ft', 'acre', 'mi'];
            if (metric)
              units = ['cm', 'm', 'hectare', 'km' ];
            let bestUnit = units[0];
            if (umExp < 0)
              bestUnit = units[units.length-1];
            for (const symName of units) {
              const sym = symbols[symName];
              const unitsRatio = umExp / sym.umExp;
              if (unitsRatio !== (unitsRatio |0))
                continue;
              const quotient = Math.pow(sym.val, unitsRatio);
              const valAdjusted = val/quotient;
              if (umExp > 0) {
                if (valAdjusted < 1) // last unit with val >= 1 (if possible)
                  break;
                bestUnit = symName;
                displayExp = unitsRatio;
              } else {
                if (valAdjusted >= 1) { // first unit with val >= 1
                  bestUnit = symName;
                  displayExp = unitsRatio;
                  break;
                }
              }
            }
            const sym = symbols[bestUnit];
            unitsStr = " ";
            const unitsRatio = umExp / sym.umExp;
            const quotient = Math.pow(sym.val, unitsRatio);
            if (displayExp < 0) {
              unitsStr = " /";
              displayExp = -displayExp;
            }
            val = val / quotient;
            unitsStr += bestUnit;
            if (displayExp != 1)
              unitsStr += String(displayExp);
          }
        }
        if (opts?.saveMode || Math.abs(val) < 10000 * EPSILON) {
          // full precision value
          return String(val) + unitsStr;
        } else {
          // Avoids display of nonsense like 2.5000...001 while
          // maintaining accuracy to "DIGITS_PRECISION" decimal digits.
          val = val.toFixed(DIGITS_PRECISION);
          while (val.endsWith("0"))
            val = val.substr(0, val.length-1);
          if (val.endsWith("."))
            val = val.substr(0, val.length-1);
          return val + unitsStr;
        }
      }

      function updateResult() {
        try {
          const ft = getField('ft', 0);
          const inch = getField('inch', 0);
          const num = getField('num', 0);
          const denom = getField('denom', 1);
          const times = getField('times', 1);
          const div = getField('div', 1);
          if (denom === 0 || div === 0) throw "Divide by zero";

          let totalInches = (ft*12 + inch + num/denom) * times / div;
          if (isNaN(totalInches)) throw "Bad input";
          if (!isFinite(totalInches)) throw "Divide by zero"

          showFeetInchesResult(totalInches*IN, /* updateExpr */ true);
        }
        catch (e) {
          showError(e);
        }
      }

      function showError(e, allErrors) {
        // always update the text, in case the error box is already showing
        let msg = e;
        if (e instanceof ChattyError)
          msg = e.message;
        document.getElementById('error').textContent = String(msg);
        if (!allErrors && e instanceof ChattyError)
          return;
        // we had an error so hide the results block and show the error block
        document.getElementById('results').style.display = 'none';
        document.getElementById('numberResults').style.display = 'none';
        document.getElementById('error').style.display = '';
      }

      //
      // Parser, for general calculation with expressions
      //

      let parsestr = "", initialParseStr = "";
      let parsepos = 0, parseFurthest = 0;
      const DIGITS = "0123456789";
      const ALPHA =
        "abcdefghijklmnopqrstuvwxyz" +
        "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
      const ALPHANUM = ALPHA + DIGITS;
      const NOSKIP = { noSkip: true };

      function peekc() {
        if (parsepos < parsestr.length)
          return parsestr.charAt(parsepos);
        return null;
      }

      function getc() {
        if (parsepos < parsestr.length) {
          let ch = parsestr.charAt(parsepos);
          parsepos += 1;
          if (parsepos > parseFurthest && parsestr === initialParseStr)
            parseFurthest = parsepos;
          return ch;
        }
        return null;
      }

      function take(match, opts) {
        const backtrack = parsepos;
        if (!opts?.noSkip)
          skipSpaces();
        if (parsestr.charAt(parsepos) === match) {
          parsepos += 1;
          return true;
        }
        parsepos = backtrack;
        return false;
      }

      function skipSpaces() {
        let foundSpace = false;
        let ch = peekc();
        while (ch === " " || ch === "\t") {
          getc();
          ch = peekc();
          foundSpace = true;
        }
        return foundSpace;
      }

      // Numbers of form:
      //    ddd
      //    ddd.
      //    ddd.dd
      //    .ddd

      function parseNum(opts) {
        const backtrack = parsepos;
        let nDigits = 0;
        if (!opts?.noSkip)
          skipSpaces();
        let ch = peekc();
        if (DIGITS.includes(ch) || ch === ".") {
          let val = 0, div = 1;
          while (DIGITS.includes(ch)) {
            val = val*10 + parseInt(ch);
            getc();
            ch = peekc();
            nDigits += 1;
          }
          if (!opts?.intOnly && take('.', NOSKIP)) {
            ch = peekc();
            while (DIGITS.includes(ch)) {
              val = val*10 + parseInt(ch);
              div *= 10;
              getc();
              ch = peekc();
              nDigits += 1;
            }
          }
          const backtrack2 = parsepos;
          if (!opts?.intOnly && take('e', NOSKIP)) {
            take('+', NOSKIP);
            take('-', NOSKIP);
            if (DIGITS.includes(peekc())) {
              // let JavaScript parse the number
              while (DIGITS.includes(peekc()))
                getc();
              let str = parsestr.substring(backtrack, parsepos);
              let val = Number.parseFloat(str);
              if (isNaN(val)) {
                parsepos = backtrack;
                throw `Bad number: ${str}`;
              }
              return val;
            }
          }
          parsepos = backtrack2;
          if (nDigits > 0)
            return val/div; 
          parsepos = backtrack;    
        }
        return null;
      }

      // Parse a number or a number followed by fraction or a fraction:
      //    n
      //    n n/n
      //    n/n

      function parseNumFrac(opts) {
        let val = parseNum(opts);
        if (val === null)
          return null;
        const backtrack = parsepos;
        if (take('/', NOSKIP)) {
          let denom = parseNum({ noSkip: true, intOnly: true });
          if (denom === null) {
            parsepos = backtrack;
            return val;
          }
          const q = val/denom;
          if (!isFinite(q)) throw "Divide by zero";
          return q;
        }
        let num = parseNum({ intOnly: true });
        if (num === null)
          return val;
        if (take('/'), NOSKIP) {
          let denom = parseNum({ noSkip: true, intOnly: true });
          if (denom !== null) {
            const q = num/denom;
            if (!isFinite(q)) throw "Divide by zero";
            return val + q;
          }
        }
        parsepos = backtrack;
        return val;
      }

      // Parse a value, which is either a plain number (n) or a sequesnce of
      // number-fractions (nf) each followed by a unit:
      //    n
      //    nf unit
      //    nf unit [ nf unit ['^' n]? ]*
          
      function parseValue(opts) {
        const backtrack1 = parsepos;
        let num = 0, umExp = 0;
        let lastUnitVal = Number.POSITIVE_INFINITY;
        let metric = true;   // consider it metric unless we encounter any non-metric unit

        // The idea of lastUnitVal is that units should get progressively smaller.
        // Otherwise, someone could enter 2'3' when they meant 2'3"

        while (true) {
          const backtrack2 = parsepos;
          let val = parseNumFrac(opts);
          if (val === null)
            break;
          if (take("'")) {
            if (FT >= lastUnitVal || (umExp !== 0 && umExp != 1)) throw "Implausible units";
            lastUnitVal = FT;
            umExp = 1;
            num += val*FT;
            metric = false;
          } else if (take('"')) {
            if (IN >= lastUnitVal || (umExp !== 0 && umExp != 1)) throw "Implausible units";
            lastUnitVal = 1;
            umExp = 1;
            num += val*IN;
            metric = false;
          } else {
            // system and user-defined units
            let hasSlash = take('/');
            let word = parseWord({ ...opts, noSkip: hasSlash });
            if (word) {
              const symVal = getSymbol(word);
              if (!symVal)
                throw new ChattyError(`Unknown unit: "${word}"`);
              if (!symVal.umExp || !symVal.val)
                throw new ChattyError(`Not a unit: "${word}"`);
              let exp = symVal.umExp, val1 = symVal.val;
              if (hasSlash) {
                exp = -exp;
                val1 = 1/val1;
              }
              if (symVal.val >= lastUnitVal || (umExp !== 0 && umExp !== exp))
                throw "Implausible units";
              lastUnitVal = symVal.val;
              umExp = exp;
              num += val * val1;
              if (!symVal.metric)
                metric = false;
            } else {
              parsepos = backtrack2;
              break;
            }
          }
        }
        if (umExp !== 0)
          return { type: 'num', umExp: umExp, val: num, metric: metric };
        parsepos = backtrack1;
        num = parseNum(opts);
        if (num !== null)
          return  {type: 'num', umExp: 0, val: num };
        return null;
      }

      // Parse a word

      function parseWord(opts) {
        const backtrack = parsepos;
        if (!opts?.noSkip)
          skipSpaces();
        if (ALPHA.includes(peekc())) {
          let word = getc();
          while (ALPHANUM.includes(peekc()))
            word += getc();
          return word;
        }
        parsepos = backtrack;
        return null;
      }

      const symbols = {
        pi: Math.PI,
        in: { type: 'num', umExp: 1, val: IN, name: "inch" },
        ft: { type: 'num', umExp: 1, val: FT, name: "foot" },
        mi: { type: 'num', umExp: 1, val: 5280*FT, name: "mile" },
        acre: { type: 'num', umExp: 2, val:  66*FT * 660*FT },
        mm: { type: 'num', umExp: 1, val: MM, name: "milimeter", metric: true },
        cm: { type: 'num', umExp: 1, val: CM, name: "centimeter", metric: true },
        m:  { type: 'num', umExp: 1, val: M, name: "meter", metric: true },
        km: { type: 'num', umExp: 1, val: KM, name: "kilometer", metric: true },
        hectare: { type: 'num', umExp: 2, val: (100*M)**2, name: "hectare", metric: true },

        // General n-dimensional hypotenuse
        hyp: function(...params) {
          if (params.length < 1)
            return { type: 'num', umExp: 0, val: 0 };
          let val = params.pop();
          let umExp = val.umExp;
          let metric = val.metric;
          let accum = 0;
          while (true) {
            if (val.val !== 0) {
              if (val.type !== 'num') throw `${this.sym}(x): illegal parameter`;
              if (val.umExp != umExp) {
                if (accum !== 0) throw `${this.sym}(): parameter types incompatible`;
                type = val.type;
              }
              accum += val.val * val.val;
              if (!val.metric)
                metric = false;
            }
            val = params.pop();
            if (!val)
              break;
          }
          return { type: 'num', umExp: umExp, val: Math.sqrt(accum), metric:metric };
        },

        // Square root
        sqrt: function(...params) {
          if (params.length !== 1) throw `${this.sym}(): needs one parameter`;
          let val = params[0];
          if (val.type !== 'num') throw `${this.sym}(x): illegal parameter`;
          let umExp = val.umExp/2;
          if (umExp !== (umExp|0)) throw `${this.sym}(x): parameter must have even units`;
          return { type: 'num', umExp: umExp, val: Math.sqrt(val.val), metric: val.metric };
        },

        mean: function(...params) {
          if (params.length < 1) throw `${this.sym}(): no parameters`;
          let val = params.pop();
          let umExp = val.umExp;
          let metric = val.metric;
          let accum = 0, n = 0;
          while (true) {
            if (val.type !== 'num') throw `${this.sym}(x): illegal parameter`;
            if (val.val === 0) {
              n += 1;
            } else {
              if (val.umExp != umExp) {
                if (accum !== 0) throw `${this.sym}(): parameter types incompatible`;
              }
              accum += val.val;
              n += 1;
              if (!val.metric)
                metric = false;
            }
            val = params.pop();
            if (!val)
              break;
          }
          return { type: 'num', umExp: umExp, val: accum/n, metric: metric };
        },

        // Force metric units
        Metric: function(...params) {
          if (params.length !== 1) throw `${this.sym}(): needs one parameter`;
          let val = params[0];
          if (val.type !== 'num') throw `${this.sym}(x): illegal parameter`;
          return { ...val, metric: true };
        },

        // Force US Customary Units
        USCU: function(...params) {
          if (params.length !== 1) throw `${this.sym}(): needs one parameter`;
          let val = params[0];
          if (val.type !== 'num') throw `${this.sym}(x): illegal parameter`;
          return { ...val, metric: false };
        },

        // Easter egg function that defines a bunch of units
        Egg: function(p) {
          const addUnit = (sym, inches, exp) => {
            exp = exp ?? 1;
            userSymbols[sym] = { sym: sym, type: 'num', umExp: exp, val: inches };
          }
          // https://en.wikipedia.org/wiki/United_States_customary_units#Length  
          addUnit('fathom', 6*FT);
          addUnit('league', 3*MI);
          addUnit('chain', 66*FT);
          addUnit('furlong', 66*FT*10); // 10 chains
          addUnit('rod', 66*FT/4);      // chain/4
          addUnit('link', 66*FT/100);   // chain/100
          addUnit('point', IN/72);
          addUnit('pica', IN/6);        // 1/6", 12 points
          showUserSymbols();
          throw "Surprise!";
        }
      };

      const userSymbols = {};
      let environment = {};

      function getSymbol(name) {
        let val = environment[name];
        if (val === undefined)
          val = userSymbols[name];
        if (val === undefined)
          val = symbols[name];
        if (typeof val === 'number')
          val = { type: 'num', umExp: 0, val: val };
        else if (val instanceof Function)
          val = { type: 'fn', sym: name, params:["..."], native: val, body: `#builtin-${name}#` };
        // special case to create pseudo-variables for powered units
        const match = /^([a-z]+)([0-9]+)$/i.exec(name);
        if (match) {
          let val2 = getSymbol(match[1]);
          let exp = Number(match[2]);
          if (val2 && val2.type === 'num' && val2.umExp && val2.val && exp > 1)
            return { type: 'num', umExp: val2.umExp * exp, val: Math.pow(val2.val, exp), metric: val2.metric };
        }
        return val;
      }

      function invokeFunction(symVal, params) {
        if (symVal.type !== 'fn') throw "Not a function";
        if (symVal.native)
          return symVal.native(...params);
        if (params.length !== symVal.params.length)
           throw new ChattyError(`incorrect number of params for ${symVal.sym}(${symVal.params.join(',')})`);
        const saveEnv = environment, saveParsestr = parsestr, saveParsepos = parsepos;
        try {
          parsestr = symVal.body;
          parsepos = 0;
          environment = {};
          for (const i in params)
            environment[symVal.params[i]] = params[i];
          let val = parseExpr();
          skipSpaces();
          if (peekc()) throw "Invalid function";
          return val;
        }
        finally {
          environment = saveEnv;
          parsestr = saveParsestr;
          parsepos = saveParsepos;
        }
      }

      // Parse a term, which is either a unary expression, a
      // parenthesized expression, a function call, or a value or a word (variable)
      //    '+' term
      //    '-' term
      //    '/' term     -- reciprocal
      //    '(' expr ')'
      //    term [ '(' [ expr [ ',' expr ]* ]? ')' ]+
      //    value
      //    word

      function parseTerm(opts) {
        const backtrack = parsepos;

        // Deal with unary first
        if (take('+')) {
          let val = parseTerm(opts);
          if (val !== null)
            return val;
          parsepos = backtrack;
          return null;
        }
        if (take('-')) {
          let val = parseTerm(opts);
          if (val !== null) {
            if (val.type === 'fn') throw new ChattyError("Can't negate functions");
            if (val.type === 'parse')
              return { type: 'parse', op: 'neg', expr: val };
            return { type: val.type, umExp: val.umExp, val: -val.val, metric: val.metric };
          }
          parsepos = backtrack;
          return null;
        }
        if (take('/')) {
          let val = parseTerm(opts);
          if (val !== null) {
            if (val.type === 'fn') throw new ChattyError("can't divide functions");
            if (val.type === 'parse')
              return { type: 'parse', op: 'recip', expr: val };
            const q = 1/val.val;
            if (!isFinite(q)) throw "Divide by zero";
            return { type: val.type, umExp: -val.umExp, val: q, metric: val.metric };
          }
          parsepos = backtrack;
          return null;
        }

        // Now deal with exprs that might or might not be followed by function invocation
        let val = null;
        if (take('(')) {
          let val1 = parseExpr(opts);
          if (val1 && take(')')) {
            val = val1;
          }
        } else {
          const word = parseWord(opts);
          if (word !== null) {
            let val1 = getSymbol(word);
            skipSpaces();
            // As a special case, a function of no arguments can be used as a constant
            if (peekc() !== '('
                && val1 instanceof Object && val1.type === 'fn' && val1.params.length === 0)
              val = invokeFunction(val1, []);
            else if (!(val1 instanceof Object && val1.type))
              throw new ChattyError(`Unknown variable: "${word}"`);
            else
              val = val1;
          } else {
            if (opts?.noUnits) {
              val = parseNum(opts);
              if (val !== null)
                val = { type: 'num', umExp: 0, val: val };
            } else {
              val = parseValue(opts);
            }
          }
        }
        if (val === null) {
          parsepos = backtrack;
          return null;
        }

        // This loops because a function can return a function
        while (take('(')) {
          const params = [];
          let arg = parseExpr(opts);
          while (arg !== null) {
            params.push(arg);
            if (!take(','))
              break;
            arg = parseExpr(opts);
          }
          if (!take(')')) {
            parsepos = backtrack;
            return null;
          }
          let paramsParse = false;
          for (const p of params)
            if (p.type === 'parse')
               paramsParse = true;
          if (paramsParse || val.type === 'parse')
            val = { type: 'parse', op: 'call', expr: val, params: params };
          else
            val = invokeFunction(val, params);
        }
        return val;
      }

      // Parse an exponentiation expression (right-associative)
      //    term '^' exponentiation
      //    term

      function parseExponentiation(opts) {
        let val = parseTerm(opts);
        if (val === null)
          return null;
        const backtrack = parsepos;
        if (take('^')) {
          let exp = parseExponentiation({ ...opts, noUnits: true });
          if (!exp) {
            parsepos = backtrack;
            return val;
          }
          if (val.type === 'fn' || exp.type === 'fn')
            throw "Cannot exponentiate functions";
          if (val.type === 'parse' || exp.type === 'parse')
            return { type: 'parse', op: 'exp', expr1: val, expr2: exp };
          if (exp.umExp != 0)
            throw "Must exponentiate with a scalar";
          if (val.umExp != 0 && exp.val !== (exp.val|0))
            throw "Cannot exponentiate non-scalars by non-integers";
          return { type: 'num', umExp: val.umExp * exp.val,
            val: Math.pow(val.val, exp.val), metric: val.metric };
        }
        return val;
      }

      // Parse a multiplicitive expression:
      //    exponentiation [ '*' exponentiation ]*
      //    exponentiation [ '/' exponentiation ]*

      function parseMulExpr(opts) {
        function isMetric(val1, val2) {
          return val1.metric && val2.metric
              || val1.umExp === 0 && val2.metric
              || val2.umExp === 0 && val1.metric;
        }
        const backtrack = parsepos;
        let val = parseExponentiation(opts);
        if (val === null)
          return null;
        while (true) {
          if (take('*')) {
            let val2 = parseExponentiation(opts);
            if (val2 === null) {
              parsepos = backtrack;
              return null;
            }
            if (val.type === 'fn' || val2.type === 'fn')
              throw "Can't multiply functions";
            if (val.type === 'parse' || val2.type === 'parse')
              val = { type: 'parse', op: '*', expr1: val, expr2: val2 };
            else if (val.type === 'num' && val2.type === 'num')
              val = { type: 'num', umExp: val.umExp + val2.umExp, val: val.val * val2.val,
                metric: isMetric(val, val2) };
            else
              throw "Unknown value type";
          } else if (take('/')) {
            let val2 = parseExponentiation(opts);
            if (val2 === null) {
              parsepos = backtrack;
              return null;
            }
            if (val.type === 'fn' || val2.type === 'fn')
              throw "Can't divide functions";
            if (val.type === 'parse' || val2.type === 'parse') {
              val = { type: 'parse', op: '/', expr1: val, expr2: val2 };
            } else if (val.type === 'num' && val2.type === 'num') {
              const q = val.val / val2.val;
              if (!isFinite(q)) throw "Divide by zero";
              val = { type: 'num', umExp: val.umExp - val2.umExp, val: q,
                metric: isMetric(val, val2) };
            } else {
              throw "Unknown value type";
            }
          } else {
            break;
          }
        }
        return val;
      }

      // Parse an (additive) expression:
      //    mulexpr [ '+' mulexpr ]*
      //    mulexpr [ '-' mulexpr ]*

      function parseExpr(opts) {
        function isMetric(val1, val2) {
          return val1.metric && val2.metric
              || val1.umExp === 0 && val2.metric
              || val2.umExp === 0 && val1.metric;
        }
        const backtrack = parsepos;
        let val = parseMulExpr(opts);
        if (val === null)
          return null;
        while (true) {
          if (take('+')) {
            let val2 = parseMulExpr(opts);
            if (val2 === null) {
              parsepos = backtrack;
              return null;
            }
            if (val.type === 'fn' || val2.type === 'fn')
              throw new ChattyError("Can't add functions");
            if (val.type === 'parse' || val2.type === 'parse') {
              val = { type: 'parse', op: '+', expr1: val, expr2: val2 };
            } else if (val2.val === 0) {
              // special case for adding 0; keep first val
            } else if (val.val === 0) {
              val = val2;  // special case for adding 0; take second val
            } else if (val.type === 'num' && val2.type === 'num') {
              if (val.umExp == val2.umExp) 
                val = { type: 'num', umExp: val.umExp, val: val.val + val2.val,
                metric: val.metric && val2.metric };
              else
                throw new ChattyError("Cannot add different unit types")
            } else {
              throw "Unknown value type";
            }
          } else if (take('-')) {
            let val2 = parseMulExpr(opts);
            if (val2 === null) {
              parsepos = backtrack;
              return null;
            }
            if (val.type === 'fn' || val2.type === 'fn')
              throw "Can't subtract functions";
            if (val.type === 'parse' || val2.type === 'parse') {
              val = { type: 'parse', op: '-', expr1: val, expr2: val2 };
            } else if (val2.val === 0) {
              // special case for subtracting 0; take first val
            } else if (val.type === 'num' && val2.type === 'num') {
              if (val.umExp === val2.umExp)
                val = { type: 'num', umExp: val.umExp, val: val.val - val2.val,
                  metric: val.metric && val2.metric };
              else
                throw new ChattyError("Cannot subtract different unit types")
            }
            else {
              throw "Unknown value type";
            }
          } else {
            break;
          }
        }
        return val;
      }

      // Parse a statement:
      //    expr
      //    word '=' expr
      //    word '(' [ word [ ',' word ]* ]? ')' '=' expr

      function parseStatement(opts) {
        const backtrack = parsepos;
        let word = parseWord(opts);
        if (word !== null) {
          if (take('=')) {
            let val = parseExpr(opts);
            if (val) {
              return { ...val, sym: word, defined: true };
            }
          }
          if (take('(')) {
            let params = [];
            let param = parseWord(opts);
            while (param !== null) {
              params.push(param);
              if (!take(','))
                break;
              param = parseWord(opts);
            }
            if (take(')') && take('=')) {
              // make sure the parameters all have different names
              const paramNames = {};
              for (const p of params) {
                if (paramNames[p]) throw `duplicate parameter ${p} in function ${word}`;
                paramNames[p] = true;
              }
              const saveEnv = environment;
              try {
                environment = {};
                for (const p of params)
                  environment[p] = { type: 'parse', sym: p, defined: true };
                skipSpaces();
                const exprStart = parsepos;
                let expr = parseExpr(opts);
                environment = saveEnv;
                if (expr !== null)
                  return { type: 'fn', expr: expr, sym: word, defined: true,
                           params: params, body: parsestr.substr(exprStart) };
               }
               catch (e) {
                 environment = saveEnv;
                 throw e;
               }
             }
           }
           parsepos = backtrack;
        }
        return parseExpr();
      }

      //
      // Set up the initial parser state and parse a statement,
      // making sure all the input is consumed.
      //
      function parseInputStatement(stmt, env, opts) {
        parsestr = initialParseStr = stmt;
        parsepos = 0;
        parseFurthest = 0;
        environment = env || {};
        let val = parseStatement(opts);
        skipSpaces();
        if (val === null || peekc()) {
          let rest = parsestr.substr(parseFurthest);
          if (rest.length > 0)
            throw new ChattyError(`Cannot parse beyond "${rest}"`);
          else if (parsestr.trim() !== "")
            throw new ChattyError(`Incomplete input`);
        }
        return val;
      }

      function updateParse(userHitEnter) {
        clearFields();
        try {
          let val = parseInputStatement(document.getElementById('expr').value);
          if (val !== null) {
            if (userHitEnter && val.defined) {
              let sym = val.sym;
              if (symbols[sym]) {
                let name = `"${sym}"`;
                if (symbols[sym].name)
                  name = `${name} (${symbols[sym].name})`;
                throw `Cannot redefine system symbol ${name}`;
              }
              showAssignResult(val);
              delete val.defined;     // removes the flag that forces the definition
              delete userSymbols[sym];  // to put the redefined symbol at the end
              userSymbols[sym] = val;
              showUserSymbols();
            } else if (val.type === 'num' && val.umExp == 1 && !val.metric) {
              showFeetInchesResult(val.val);
            } else if (val.type === 'num') {
              showResult(val);
            } else if (val.type === 'fn' && !val.defined) {
              showAssignResult(val);
            }
            return;
          } else {
            let rest = parsestr.substr(parseFurthest);
            if (rest.length > 0)
              throw new ChattyError(`Cannot parse beyond "${rest}"`);
            else if (parsestr.trim() !== "")
              throw new ChattyError(`Incomplete input`);
          }
        }
        catch (e) {
          showError(e, userHitEnter);
        }

        // Gray out the result since we can't parse correctly right now
        document.getElementById('results').style.color = '#aaaaaa';  
        document.getElementById('numberResults').style.color = '#aaaaaa';
      }

      function clearFields() {
        for (const field of ['ft', 'inch', 'num', 'times', 'div'])
          document.getElementById(field).value = "";
      }

      function showResult(val) {
        document.getElementById('results').style.display = 'none';
        document.getElementById('numberResults').style.display = '';
        document.getElementById('error').style.display = 'none';
        document.getElementById('numberResults').style.color = '';

        document.getElementById('numberResultsDetail').textContent = val2str(val);
      }

      function escapeHTML(str) {
        return str
          .replace(/&/g, "&amp;")
          .replace(/</g, "&lt;")
          .replace(/>/g, "&gt;")
          .replace(/"/g, "&quot;")
          .replace(/'/g, "&#039;");
      }

      function showUserSymbols() {
        document.getElementById('symdefs');
        let str = "";
        // It seems like sorting is a good idea, but
        // JavaScript keeps entries in definition order and
        // it's nice to list them in the reverse order of definition
        let keys = Object.keys(userSymbols).reverse();
        for (const sym of keys) {
          let symStr = symString(userSymbols[sym]);
          if (symStr)
            str += `<p class="user-def"><span class="delete-button" onclick="deleteDef('${sym}')"></span>
              ${escapeHTML(symStr)}</p>`;
        }
        document.getElementById('symdefs').innerHTML = str;

        // Can't seem to save to local storage on unload in Safari,
        // so just do it here, I guess.
        // XXX: You can save them on beforeunload; maybe fix?
        saveUserSymbols();
      }

      function deleteDef(sym) {
        delete userSymbols[sym];
        showUserSymbols()
      }

      function symString(val, opts) {
        if (val.umExp === 1 && !opts?.saveMode) {
          let [ftStr, inStr, delta] = unitsToUSStringReps(val.val);
          return `${val.sym} = ${ftStr}${delta}`;
        }
        if (val.type === 'num') {
          return `${val.sym} = ${val2str(val, opts)}`;
        }
        if (val.type === 'fn') {
          return `${val.sym}(${val.params.join(", ")}) = ${val.body}`;
        }
        return undefined;
      }

      function showAssignResult(val) {
        let str = symString(val);
        if (!str)
          return;
        document.getElementById('results').style.display = 'none';
        document.getElementById('numberResults').style.display = '';
        document.getElementById('error').style.display = 'none';
        document.getElementById('numberResults').style.color = '';
        document.getElementById('numberResultsDetail').textContent = str;
      }

      function showFeetInchesResult(totalUnits, updateExpr) {

        document.getElementById('results').style.display = '';
        document.getElementById('numberResults').style.display = 'none';
        document.getElementById('error').style.display = 'none';
        document.getElementById('results').style.color = '';

        document.getElementById('resultIn').textContent = val2str(totalUnits/IN);
        document.getElementById('resultFt').textContent = val2str(totalUnits/FT);

        let [ftStr, inStr, delta] = unitsToUSStringReps(totalUnits);
        document.getElementById('resultFtDetail').textContent = ftStr + delta;
        if (updateExpr)
          document.getElementById('expr').value = ftStr + delta;

        document.getElementById('resultInDetail').textContent = inStr + delta;

        // show metric for good measure
        document.getElementById('resultMeters').textContent =
          val2str(totalUnits/M);
        document.getElementById('resultMetersMetricFeet').textContent =
          val2str((totalUnits/M)/(2.54/2.50));
      }

      function unitsToUSStringReps(totalUnits) {
        let totalInches = totalUnits/IN;
        let minus = "";
        if (totalInches < 0) {
          totalInches = -totalInches;
          minus = "-";
        }

        // Recover feet and inches from from result
        // (round to nearest 1/denom)
        let denom = 32;
        let inches =  ((totalInches*denom + 0.5)|0)/denom;
        let ft = (inches/12)|0;      // "n|0" truncates to an integer
        inches = inches - ft*12;
        let frac = inches - (inches|0);
        inches = inches|0;
        let num = (frac*denom)|0;
        while (denom > 2 && num%2 === 0) {  // reduce fraction
          denom = denom/2;
          num = num/2;
        }

        // format that string
        let ftStr = minus, sp = "";
        if (ft !== 0 || (inches === 0 && num === 0)) {
          ftStr += ft + "'";
          sp = " ";
        }
        if (inches !== 0) {
          ftStr += sp + inches;
          sp = " ";
        }
        if (num !== 0)
          ftStr += `${sp}${num}/${denom}`;
        if (inches !== 0 || num !== 0)
           ftStr += '"';
        let delta = totalInches - (ft*12 + inches + num/denom);
        if (Math.abs(delta) < EPSILON) {
          delta = "";
        } else {
          if (delta < 0)
            delta = ` - ${val2str(-delta)}"`;
          else
            delta = ` + ${val2str(delta)}"`;
        }
 
        // format inches
        let inStr = minus;
        sp = "";
        inches = ft*12 + inches;
        if (inches !== 0 || num === 0) {
          inStr += inches;
          sp = " ";
        }
        if (num !== 0)
          inStr += `${sp}${num}/${denom}`;
        inStr += '"';
        return [ftStr, inStr, delta];
      }

      function showHelp(id) {
        // hide all help
        let elts = document.querySelectorAll('div.help');
        for (let e of elts)
          e.style.display = ''; // back to inherited 'none'
        let helpElement = document.getElementById(id);
        if (helpElement) {
          helpElement.style.display = "block"; // inherits 'none' from "help" class
          for (let child of helpElement.children)
            if (child.tagName === 'DIV')
              child.scroll(0, 0);
        }
      }

      const GUID = "ad1f9c32-ed69-457d-89a0-f966c81424bd";
      const LOCAL_STORAGE_KEY = "FeetInchCalculator-" + GUID;
      const MAJOR = 1, MINOR = 0, PATCH = 0;

      function clearLocalStorage() {
        const localStorage = window.localStorage;
        if (!localStorage)
          return;
        localStorage.setItem(LOCAL_STORAGE_KEY, "");
        localStorage.clear();
      }

      function loadUserSymbols() {
        const localStorage = window.localStorage;
        if (!localStorage)
          return false;
        try {
          let json = localStorage.getItem(LOCAL_STORAGE_KEY);
          if (!json)
            return false;
          let wad = JSON.parse(json);
          if (!wad || !wad.major || wad.major > MAJOR)
            return false;
          if (!wad.defs)
            return false;
          for (const def of wad.defs) {
            try {
              let val = parseInputStatement(def);
              skipSpaces();
              if (val !== null && !peekc()) { // nothing left over at the end
                let sym = val.sym;
                if (symbols[sym])
                  next;
                delete val.defined;
                userSymbols[sym] = val;
              }
            }
            catch (e) {
            }
          }
          showUserSymbols();
          return true;
        }
        catch (e) {
        }
        return false;    
      }

      function saveUserSymbols() {
        const localStorage = window.localStorage;
        if (!localStorage)
          return false;
        const wad = {
          major: MAJOR, minor: MINOR, patch: PATCH, defs: []
        };
        // We rely on the fact that objects are enumerated in the order
        // items were added. Otherwise, function definitions might fail
        // due to their variable references being unsatisfied.
        for (const sym in userSymbols) {
          let symStr = symString(userSymbols[sym], { saveMode: true });
          if (symStr) {
            wad.defs.push(symStr);
            // console.log(`Saving: ${symStr}`);
          }
        }
        let json = JSON.stringify(wad);
        try {
          localStorage.setItem(LOCAL_STORAGE_KEY, json);
          return true;
        }
        catch (e) {
        }
        return false;
      }

      function addExampleStuffs() {
        for (const help of document.querySelectorAll("div.help")) {
          help.addEventListener("click", function(event) {
            let styles = window.getComputedStyle(event.target);
            let action = styles.getPropertyValue("--click-action");
            if (action.trim() === "stuff-text") {
              let text = event.target.textContent.trim();
              document.getElementById('expr').value = text.trim();
              updateParse(true);
            }
          });
        }
      }

      document.addEventListener("keydown", function(evt) {
        evt = evt || window.event;
        if (evt.key === "Escape" || evt.key === "Esc" || evt.keyCode === 27)
          showHelp();
      });

      function onLoad() {
        loadUserSymbols();
        updateResult();
        addExampleStuffs();
      }
    </script>
  </body>
</html>