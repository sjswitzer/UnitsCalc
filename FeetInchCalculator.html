<!--
  Copyright 2021 Stan Switzer

    This work is licensed under a Creative Commons Attribution-ShareAlike
    4.0 International License. https://creativecommons.org/licenses/by-sa/4.0/

  Synopsis:

    A simple tool for doing calculations with US customary units
    of length.
-->
<html>
  <head>
    <title>Feet & Inch Calculator</title>
    <base target="_blank"> <!-- all links open in a new tab/page -->
  </head>
  <body onload="onLoad()">
    <style type="text/css">
      body {
        margin: 4px 12px;
        box-sizing: border-box;
        font-family: system-ui;
        background-color: #f8f8f8;
        color: black;
      }

      /* Spiff up input fields */
      input[type="text"] {
        font-size:13pt;
        border-radius: 4px;
        padding: 1px 4px;
      }

      .right { float: right; }

      /*
       * A container that shrinks to its largest-width content
       */
      div.shrink-container {
        display: table;
        width: 1px;
      }
      span.shrink-container {
        display: inline-table;
        width: 1px;
      }
      .spread-container {  /* an element who's width forces a shrink-container's width */
        width: max-content
      }

      div.layout {
        display:table;
      }
      div.layout > div {
        display:table-cell;
        width: 100%
      }

      /*
       * Initially-hidden help content.
       * Help contains a <span> for a close button and a <div> which is made scrollable.
       */
      .help {
        padding: 0px 5px 0px 20px;
        background-color: #e8e8e8;
        position: fixed;
        display: none;
        top: 10%;
        left: 30%;
        width: 63.5%;
        height: 85%;
        border: 2px solid black;
      }
      .help > span {  /* the close buton */
        color: #888888;
        font-weight: bold;
        float: right;
        font-size: 40px;
        line-height: 40px;
        cursor: pointer;
        transition: 0.3s;
      }
      .help > span:hover {
        transform: scale(1.25);
        color: black;
      }
      .help > span:active {
        transform: scale(1.5);
      }
      .help > div {
        overflow-y: scroll;
        height: 100%;
      }
      /* styling for help content */
      .help td, .help th {
        padding: 0px 10px;
        vertical-align: top;
        text-align: left;
      }
      .help ul {
        padding-left: 20px;
      }
      .help ul > li {
        margin: 6px;
      }
      .help code {
        font-size: 130%;
        font-weight: bold;
      } 
      .help code.abstract {
        font-style: oblique;
      }

      /*
       * Makes a <span> into a button
       */
      span.button {
        display: inline-block;
        cursor: pointer;
        padding: 2px 8px;
        background: #4444ff;
        border-radius: 4px;
        color: white;
        transition: 0.3s;
      }
      span.button:hover {
        background: #0000dd;
        transform: scale(1.15);
      }
      span.button:active {
        background: #0000cc;
        transform: scale(1.3);
      }

      /* Looks like a link but is actually a "button" */
      span.linklike {
        color: #0000dd;
        cursor: pointer;
        text-decoration: underline;
      }

      /*
       * Animates the delete button for variable and function definitions
       */
      p.defn {
        margin: 5px 0px;
        font-size: 12pt;
      }
      p.defn > span:hover {
        background: #ee9999;
        transform: scale(1.15);
      }
      p.defn > span:active {
        background: #ff0000;
        transform: scale(1.3);
      }
      p.defn > span {
        display: inline-block; /* so that transform works */
        cursor: pointer;
        padding: 0px 5px;
        background: #bb8888;
        font-size: 16px;
        line-height: 16px;
        font-weight: bold;
        border-radius: 4px;
        color: white;
        transition: 0.1s;     
        visibility: hidden;
      }
      p.defn:hover > span {
        visibility: visible;
      }

      /* The results box */
      .results {
        border: 2px solid;
        margin: 10px 0px;
        padding: 0px 10px;
        border-radius: 4px;
      }

      /* Testing affordance; example text can be stuffed into the expr box */
      .help table.example td:first-child, .help code {
        cursor: pointer;
        /* text-decoration: underline; */
      }
      .help table.example td:first-child:hover, .help code:hover {
        color: #0000dd;
        text-decoration: underline;
      }
    </style>
    <div class="shrink-container">
      <div class="spread-container">
        <input type="text" style="text-align: right;"
          oninput="updateResult()" size="4" id="ft" value="5"> feet &nbsp;
        <input type="text" style="text-align: right;"
          oninput="updateResult()" size="2" id="inch" value="">
        <sup>
          <input type="text" style="text-align: right;"
            oninput="updateResult()" size="2" align="right" id="num" value="">
        </sup>/<sub>
          <input type="text" oninput="updateResult()" size="2" id="denom" value="8">
        </sub> inches
        &nbsp;&nbsp; times
        <input type="text" oninput="updateResult()" size="3" id="times" value="">
        &nbsp; divided by
        <input type="text" oninput="updateResult()" size="3" id="div" value="">
      </div>
      <div class="layout">
        <div>
          <input style="width: 100%" type="text" spellcheck="false" id="expr" value=""
            oninput="updateParse()" onchange="updateParse(true)">
        </div>
        <div>
          <span class="button" style="margin-left: 4px; font-size: 18px" onclick="showHelp('help-expr')">?</span>
        </div>
      </div>
      <div class="results">
        <p id="results">
          <span id="resultFt"></span> feet = <span id="resultFtDetail"></span>
          <br>
          <span id="resultIn"></span> inches = <span id="resultInDetail"></span>
          <br>
          <span id="resultMeters"></span> meters
          <br>
          <span id="resultMetersMetricFeet"></span> meters (assuming "metric feet")
        </p>
        <p id="numberResults">
          <span id="numberResultsDetail"></span>
        </p>
        <p id="error" style="color: red"></p>
      </div>
      <span class="button right" onclick="showHelp('help-tips')">Help</span>
      <div id="symdefs"></div>
    </div>
    <div class="help" id="help-tips">
      <span onclick="hideHelp()">&times;</span>
      <div>
        <h3> Help </h3>
        <p> Some quick tips to get you started:
        <ul>
          <li> Fields may be left empty when not relevent.
          <li> A value like five and a half feet may be entered as 5.5 feet or as 5 feet 6 inches.
          <li> A value like six and a quarter inches may be entered as 6.25 inches or
               as 6 inches and 1/4.
          <li> A "metric foot" is a convention used by the construction industry in metric
               countries where a foot is taken to be exactly 30cm instead of 30.48cm. It's an
               <a href="https://en.wikipedia.org/wiki/ISO_2848#Metric_foot">
                 international standard</a>!
          <li> You can type a fairly general expression into the text box. Click the
               <span class="button" onclick="showHelp('help-expr')">?</span> button
               for more information.
        </ul>
      </div>
    </div>
    <div class="help" id="help-expr">
      <span onclick="hideHelp()">&times;</span> 
      <div>
        <h3> Expressions </h3>
        <p> Expressions can contain numbers, units and the operators
            <code>+</code> <code>-</code> <code>*</code> and <code>/</code>.
            Multiplication and division are performed before addition and subtraction, and
            parenthesis can be used for grouping. Spaces are generally optional.
        <p> Units include:
            <code>ft</code> <code>'</code> <code>in</code> <code>"</code> 
            <code>m</code> and <code>cm</code>.
            The unit names can be used as constants as well.
        <p> As you type, the expression might be momentarily unparsable, e.g.,
            <code>3'+</code>, until you finish typing. 
            The results box will be grayed out while that happens.
            It would be too noisy to alert each of these errors, but if you don't 
            know why it's grayed out, you can hit enter to see an error message.
        </p>
        <table class="example">
          <colgroup>
            <col style="width: 8em">
            <col style="width: auto">
          </colgroup>
          <tr>
            <th> Example
            <th> Description
          <tr>
            <td> 5' 6"
            <td> An ordinary distance
          <tr>
            <td> 5' 6 3/8" / 3
            <td> Divide 5 feet 6 and 3/8 inches by 3
          <tr>
            <td> 5 1/2' - 8"
            <td> Subtracts lengths
          <tr>
            <td> 5.5'
            <td> You can use decimal values instead of fractions
          <tr>
            <td> 3/4"
            <td> You can use just a fraction
          <tr>
            <td> (5'6" + 7') / 2
            <td> The average of 5'6" and 7'
          <tr>
            <td> 5'10 3/8" * 3/4
            <td> 3/4 of 5' 10 3/8"
          <tr>
            <td> 12' / 6"
            <td> The ratio of 12' and 6" (result is 24)
          <tr>
            <td> 1 + 2 * 3
            <td> Ordinary math (note order of operations; result is 7)
          <tr>
            <td> (1 + 2) * 3
            <td> Result is 9
          <tr>
            <td> 1m - 2cm
            <td> One meter minus two centimeters
         <tr>
            <td> ft
            <td> A foot
          <tr>
            <td> ft * 12
            <td> 12 feet; notice that such units are simply length-valued variables
          <tr>
            <td> 5' 6" * pi
            <td> Circumference of a 5' 6" diameter circle
          <tr>
            <td> hyp(3', 4')
            <td> Hypotenuse of a right triangle with sides 3' and 4' (result is 5')
        </table>
        <h3> Terms </h3>
        <p> Expressions are built up out of <i>terms</i> which are either
          <ul>
            <li> A plain number such as <code>12</code>, <code>7.</code>,
                 <code>3.14</code>, <code>.15</code>, etc.
            <li> A variable name, such as <code>pi</code>
            <li> A <i>length</i> which can be a number, a fraction, or a number
                 and a fraction followed buy a <i>unit</i>
            <li> Any sequence of the the previous length-unit combinations as long as
                 the units are of descending size
          </ul>
        <p> A <i>unit</i> is either <code>'</code> (feet), <code>ft</code> (feet),
            <code>"</code> (inches), <code>in</code> (inches), <code>m</code> (meters),
            or <code>cm</code> (centimeters).
            In fact, any <i>variable</i> you define as a length can be used as a unit
            (<code>ft</code>, <code>in</code>, <code>m</code>, and <code>cm</code> are simply
            predefined immutable variables).
        <p> For example, if you enter
            <code>yd = 3'</code>, you can then use expressions like <code>3yd 5 1/2"</code>.
            Potentially useful definitions besides <code>yd</code> are <code>mi = 5280'</code>
            and <code>km = 1000m</code>.
        <p> Units must be specified in descending order.
            You can use <code>12'3"</code> but you can't use <code>12"3'</code>.
            This is to prevent accidentally typing <code>12'3'</code> when you really
            meant <code>12'3"</code>.
            You can type nonsense like <code>3 1/2m 3.5"</code> if you want, but you won't
            do it by accident.
        <h3> Variables </h3>
        <p> Define variables by typing <code class="abstract">name = expression</code>
            then hitting "enter."
            For instance, <code>frontage = 45'4 3/4"</code>. You can then use those values
            in later expressions, e.g. <code>frontage/3</code>.
            Amusingly, perhaps, because <code>frontage</code> is a length, it can also be
            used as a unit: <code>1/3 frontage</code> or <code>1/3frontage</code>.
        <p> The variables <code>ft</code>, <code>in</code>, <code>m</code>, and <code>cm</code>
            are predefined for use as values or as units. The variable <code>pi</code> is
            predefined in case you care about circles. Predefined variables cannot be changed.
        <h3> Functions </h3>
        <p> Define functions by typing
            <code class="abstract">name(param,param,&hellip;) = expression</code>
            then hitting "enter." For instance, you can define a function to average to numbers
            or lengths: <code>average(x,y) = (x+y)/2</code> (but the predefined function
            <code>mean(&hellip;)</code> already does that, so&hellip;).
        <p> Function bodies can use any of their parameters (<i>of course</i>) and variables
            that have already been defined. As a special case, a function with no parameters
            can be used as a "dynamic variable." That is, assuming variables <code>a</code>
            and <code>b</code> are already defined, the function
            <code>c() = a + b</code> can be invoked as <code>c()</code> or <code>c</code>,
            and in either case gives you the current value of <code>a + b</code>.
        <h4> Built-In Functions </h4>
        <table>
          <colgroup>
            <col style="width: 8em">
            <col style="width: auto">
          </colgroup>
          <tr>
            <th> Function
            <th> Description
          <tr>
            <td> mean(x,y,&hellip;) 
            <td> the average of a set of numbers or lengths
          <tr>
            <td> hyp(x,y,&hellip;) 
            <td> the hypotenuse of a triangle or, more usefully, the diagonal of a rectangle
        </table>
        <h3> Saved State </h3>
        <p> User-defined variables and functions are saved between sessions in local
            storage. In case you run into a problem with that, you can
            <span class="linklike" onclick="clearLocalStorage()">clear</span>
            local storage.
        <h3> Odds And Ends </h3>
        <p> <span class="linklike" onclick="showHelp('help-boring')">Boring details</span>
            if you're interested.
      </div>
    </div>
    <div class="help" id="help-boring">
      <span onclick="hideHelp()">&times;</span>
      <div>
        <h3> Boring Details </h3>
        <p> This program started out as a quick and dirty tool to easily divide
            lengths given in feet and inches into equal parts, a common task
            in the construction industry and quite tedious to work out by hand.
            The vestiges of that are seen in the top line of the current
            user interface.
        <p> But I started to think of it as a <i>calculator</i> and wondered
            if it could be generalized to do arbitrary math with lengths. The result
            is what you see here. It's not clear how useful any of that functionality
            is but it was a good excuse to tinker.
        <p> One could easily imagine extending it further. For example, it currently
            deals only in lengths and numbers. So it's possible to add two lengths,
            resulting in another length, or to multiply or divide a length by a number.
            You can divide a length by a length to get a number (the ratio of lenghts),
            but you can't multiply two numbers. Why? Because that would be an <i>area</i>
            and this program doesn't know about areas. But nothing says it couldn't!
        <p> This line of thinking leads to
            <a href="https://en.wikipedia.org/wiki/Dimensional_analysis">dimensional analysis</a>,
            and there are already some very good programs out there for that including the
            legendary
            <a href="https://linux.die.net/man/1/units">Unix "units" command</a>.
            Hell, <a href="https://www.google.com/search?q=12+acres+%2F+100+feet">
            Google will do it for you</a> if you ask it nicely.
        <p> The main distinction this tool has is that it deals naturally with notations
            typically used with feet and inches. But, <i>sigh</i>,
            <a href="https://www.google.com/search?q=5%27+6+3%2F8%22+%2F+3">
            Google will do that for you too</a>.
        <p> Oh well, it was a good excuse to spiff up my HTML, CSS, and JavaScript skills.
            Not a bad weekend project.
        <p> Copyright &copy; 2021, Stan Switzer
        <div style="float: left; margin: 0px 8px 70px 0px">
          <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">
            <img alt="Creative Commons License" style="border-width:0"
              src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png">
          </a>
        </div>
        <p> This work is licensed under a
          <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">
            Creative Commons Attribution-ShareAlike 4.0 International License
          </a>.
        <br> Find source on
            <a href="https://gist.github.com/sjswitzer/77288511a213dd0d973d99a941ac909e">GitHub</a>
      </div>
    </div>
    <script type="text/javascript">
      "use strict";

      // A curious thing worth noting: It turns out that fractions of the form
      // "n / power-of-2" are precicely the values that can be represented exactly
      // in floating point arithmetic and also the conventional way of expressing
      // fractional inches. So doing all arithmetic in units of inches means that
      // calculations can be exact when exact results are possible.

      // Errors that are too chatty to show while typing.
      // Error will be shown if the user hits "enter."
      class ChattyError extends Error {
        constructor(msg) {
          super();
          this.message = msg;
        }
      }

      //
      // Simple interface for common operations
      //

      function getField(name, def) {
        document.getElementById(name).style.color = '';
        let val = document.getElementById(name).value.trim();
        if (val === "") return def;
        val = parseFloat(val);
        if (isNaN(val) || (val === 0 && def !== 0))
          document.getElementById(name).style.color = 'red';
        return val;
      }

      const DIGITS_PRECISION = 10, EPSILON = Math.pow(10, -DIGITS_PRECISION);

      function num2str(val) {
        // Avoids display of nonsense like 2.5000...001 while
        // maintaining accuracy to "DIGITS_PRECISION" decimal digits.
        val = val.toFixed(DIGITS_PRECISION);
        while (val.endsWith("0"))
          val = val.substr(0, val.length-1);
        if (val.endsWith("."))
          val = val.substr(0, val.length-1);
        return val;
      }

      function updateResult() {
        try {
          const ft = getField('ft', 0);
          const inch = getField('inch', 0);
          const num = getField('num', 0);
          const denom = getField('denom', 1);
          const times = getField('times', 1);
          const div = getField('div', 1);
          if (denom === 0 || div === 0) throw "Divide by zero";

          let totalInches = (ft*12 + inch + num/denom) * times / div;
          if (isNaN(totalInches)) throw "Bad input";

          showResult(totalInches, true);
        }
        catch (e) {
          showError(e);
        }
      }

      function showError(e, allErrors) {
        // always update the text, in case the error box is already showing
        let msg = e;
        if (e instanceof ChattyError)
          msg = e.message;
        document.getElementById('error').textContent = String(msg);
        if (!allErrors && e instanceof ChattyError)
          return;
        // we had an error so hide the results block and show the error block
        document.getElementById('results').style.display = 'none';
        document.getElementById('numberResults').style.display = 'none';
        document.getElementById('error').style.display = '';
      }

      //
      // Parser, for general calculation with expressions
      //

      let parsestr = "", initialParseStr = "";
      let parsepos = 0, parseFurthest = 0;
      const DIGITS = "0123456789";
      const ALPHA =
        "abcdefghijklmnopqrstuvwxyz" +
        "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
      const ALPHANUM = ALPHA + DIGITS;

      function peekc() {
        if (parsepos < parsestr.length)
          return parsestr.charAt(parsepos);
        return null;
      }

      function getc() {
        if (parsepos < parsestr.length) {
          let ch = parsestr.charAt(parsepos);
          parsepos += 1;
          if (parsepos > parseFurthest && parsestr === initialParseStr)
            parseFurthest = parsepos;
          return ch;
        }
        return null;
      }

      function take(match, noskip) {
        if (!noskip)
          skipSpaces();
        if (parsestr.charAt(parsepos) === match) { // make the single character case faster
          parsepos += 1;
          return true;
        }
        if (parsestr.substr(parsepos, match.length).toLowerCase() !== match)
          return false;
        parsepos += match.length;
        return true;
      }

      function skipSpaces() {
        let foundSpace = false;
        let ch = peekc();
        while (ch === " " || ch === "\t") {
          getc();
          ch = peekc();
          foundSpace = true;
        }
        return foundSpace;
      }

      // Numbers of form:
      //    ddd
      //    ddd.
      //    ddd.dd
      //    .ddd

      function parseNum() {
        const backtrack = parsepos;
        let nDigits = 0
        skipSpaces();
        let ch = peekc();
        if (DIGITS.includes(ch) || ch === ".") {
          let val = 0, div = 1;
          while (DIGITS.includes(ch)) {
            val = val*10 + parseInt(ch);
            getc();
            ch = peekc();
            nDigits += 1;
          }
          if (take('.', true)) {
            ch = peekc();
            while (DIGITS.includes(ch)) {
              val = val*10 + parseInt(ch);
              div *= 10;
              getc();
              ch = peekc();
              nDigits += 1;
            }
          }
          if (nDigits > 0)
            return val/div; 
          parsepos = backtrack;    
        }
        return null;
      }

      // Parse a number or a number followed by fraction or a fraction:
      //    n
      //    n n/n
      //    n/n

      function parseNumFrac() {
        let val = parseNum();
        if (val === null)
          return null;
        const backtrack = parsepos;
        if (take('/')) {
          let denom = parseNum();
          if (denom === null) {
            parsepos = backtrack;
            return val;
          }
          if (denom === 0) throw "Divide by zero";
          return val/denom;
        }
        let num = parseNum();
        if (num === null)
          return val;
        if (take('/')) {
          let denom = parseNum();
          if (denom !== null) {
            if (denom === 0) throw "Divide by zero";
            return val + num/denom;
          }
        }
        parsepos = backtrack;
        return val;
      }

      // Parse a value, which is either a plain number (n) or a sequesnce of
      // number-fractions (nf) each followed by a unit:
      //    n
      //    nf unit
      //    nf unit [ nf unit ]*
          
      function parseVal() {
        let backtrack1 = parsepos;
        let inches = 0, haveLength = false, lastUnit = Number.POSITIVE_INFINITY;

        // The idea of lastUnit is that units should get progressively smaller.
        // Otherwise, someone could enter 2'3' when they meant 2'3"

        while (true) {
          const backtrack2 = parsepos;
          let val = parseNumFrac();
          if (val === null)
            break;
          if (take("'")) {
            if (12 >= lastUnit) throw "Implausible units";
            lastUnit = 12;
            inches += val*12;
          } else if (take('"')) {
            if (1 >= lastUnit) throw "Implausible units";
            lastUnit = 1;
            inches += val;
          } else {
            // system and user-defined units
            let word = parseWord(), ok = false;
            if (word) {
              const symVal = getSymbol(word);
              if (!symVal)
                throw new ChattyError(`Unknown unit: "${word}"`);
              if (symVal.type !== 'in')
                throw new ChattyError(`Not a unit: "${word}"`);
              if (symVal.val >= lastUnit) throw "Implausible units";
              lastUnit = symVal.val;
              inches += val * symVal.val;
              ok = true;
            }
            if (!ok) {
              parsepos = backtrack2;
              break;
            }
          }
          haveLength = true;
        }
        if (haveLength)
          return { type: 'in', val: inches };

        // if there are no units, we can only use the plain number
        parsepos = backtrack1;
        let val = parseNum();
        if (val !== null)
          return { type: 'num', val: val };
        return null;
      }

      // Parse a word

      function parseWord() {
        const backtrack = parsepos;
        skipSpaces();
        if (ALPHA.includes(peekc())) {
           let word = getc();
           while (ALPHANUM.includes(peekc()))
             word += getc();
           return word;
        }
        parsepos = backtrack;
        return null;
      }

      const symbols = {
        pi: Math.PI,
        in: { type: 'in', val: 1 },
        ft: { type: 'in', val: 12 },
        cm: { type: 'in', val: 1/2.54 },
        m:  { type: 'in', val: 1/0.0254 },
        // Let the user define these if they want to
        //   yd: { type: 'in', val: 36 },  
        //   mi: { type: 'in', val: 5280*12 },
        //   km: { type: 'in', val: 1000/0.0254 },

        hyp: function(...params) {
          // General n-dimensional hypotenuse
          if (params.length < 1)
            return { type: 'num', val: 0 };
          let val = params.pop();
          let type = val.type;
          let accum = 0;
          while (true) {
            if (val.val !== 0) {
              if (val.type !== type) {
                if (accum !== 0) throw `${this.sym}(): parameter types incompatible`;
                type = val.type;
              }
              accum += val.val * val.val;
            }
            val = params.pop();
            if (!val)
              break;
          }
          return { type: type, val: Math.sqrt(accum) };
        },

        mean: function(...params) {
          if (params.length < 1) throw `${this.sym}()(): no parameters`;
          let val = params.pop();
          let type = val.type;
          let accum = 0, n = 0;
          while (true) {
            if (val.val === 0) {
              n += 1;
            } else {
              if (val.type !== type) {
                if (accum !== 0) throw `${this.sym}(): parameter types incompatible`;
                type = val.type;
              }
              accum += val.val;
              n += 1;
            }
            val = params.pop();
            if (!val)
              break;
          }
          return { type: type, val: accum/n };
        },

        Egg: function(p) {
          // Easter egg function that defines a bunch of units
          const addUnit = (sym, inches) => {
            userSymbols[sym] = { sym: sym, type: 'in', val: inches };
          }
          // if there's no parameter (of any type or value) just add the useful ones
          addUnit('yd', 3*12);          // 3'
          addUnit('mi', 5280*12);       // 5280'
          addUnit('km', 1000/0.0254);   // 1000m
          if (p) {
             // https://en.wikipedia.org/wiki/United_States_customary_units#Length  
            addUnit('fathom', 6*12);      // 6'
            addUnit('league', 5280*12*3); // 3 mi
            addUnit('chain', 66*12);      // 66'
            addUnit('furlong', 66*12*10); // 10 chains
            addUnit('rod', 66*12/4);      // chain/4
            addUnit('link', 66*12/100);   // chain/100
            addUnit('pica', 1/6);         // 1/6"
            addUnit('point', 1/72);       // 1/72", 12 pica
          }
          showUserSymbols();
          throw "Surprise!";
        }
      };

      const userSymbols = {};
      let environment = {};

      function getSymbol(name) {
        let val = environment[name];
        if (val === undefined)
          val = userSymbols[name];
        if (val === undefined)
          val = symbols[name];
        if (typeof val === 'number')
          val = { type: 'num', val: val };
        if (val instanceof Function)
          val = { type: 'fn', sym: name, params:["..."], native: val, body: `#builtin-${name}#` };
        return val;
      }

      function invokeFunction(symVal, params) {
        if (symVal.type !== 'fn') throw "Not a function";
        if (symVal.native) {
          let val = symVal.native(...params);
          if (val !== null)
             return val;
        }
        if (params.length !== symVal.params.length)
           throw new ChattyError(`incorrect number of params for ${symVal.sym}(${symVal.params.join(',')})`);
        const saveEnv = environment, saveParsestr = parsestr, saveParsepos = parsepos;
        try {
          environment = {};
          parsestr = symVal.body;
          parsepos = 0;
          for (const i in params)
            environment[symVal.params[i]] = params[i];
          let val = parseExpr();
          skipSpaces();
          if (peekc()) throw "Invalid function";
          return val;
        }
        finally {
          environment = saveEnv;
          parsestr = saveParsestr;
          parsepos = saveParsepos;
        }
      }

      // Parse a term, which is either a parenthesized expression, a
      // function call, or a value
      //    '(' expr ')'
      //    term [ '(' [ expr [ ',' expr ]* ]opt ')' ]+
      //    val
      //    word

      function parseTerm() {
        const backtrack = parsepos;
        let val;
        if (take('(')) {
          val = parseExpr();
          if (val === null || !take(')')) {
            parsepos = backtrack;
            return null;
          }
        } else {
          let word = parseWord();
          if (word !== null) {
            let val1 = getSymbol(word);
            skipSpaces();
            // As a special case, a function of no arguments can be used as a constant
            if (peekc() !== '('
                && val1 instanceof Object && val1.type === 'fn' && val1.params.length === 0)
              val = invokeFunction(val1, []);
            else if (!(val1 instanceof Object && val1.type))
              throw new ChattyError(`Unknown variable: "${word}"`);
            else
              val = val1;
          } else {
             val = parseVal();
             if (val === null) {
               parsepos = backtrack;
               return null;
             }
          }
        }
        if (!val) throw "should't happen"; // basically an assert
        // This loops because a function can return a function
        while (take('(')) {
          const params = [];
          var arg = parseExpr();
          while (arg !== null) {
            params.push(arg);
            if (!take(','))
              break;
            arg = parseExpr();
          }
          if (!take(')')) {
            parsepos = backtrack;
            return null;
          }
          let paramsParse = false;
          for (const p of params)
            if (p.type === 'parse')
               paramsParse = true;
          if (paramsParse || val.type === 'parse')
            val = { type: 'parse', params: params };
          else
            val = invokeFunction(val, params);
        }
        return val;
      }

      // Parse a unary operator
      // or a + or - sign followed by a term:
      //    '(' expr ')'
      //    '+' unary
      //    '-' unary
      //    term

      function parseUnary() {
        const backtrack = parsepos;
        if (take('+')) {
          let val = parseUnary();
          if (val !== null)
            return val;
          parsepos = backtrack;
          return null;
        }
        if (take('-')) {
          let val = parseUnary();
          if (val !== null) {
            if (val.type === 'fn') throw new ChattyError("Can't negate functions");
            if (val.type === 'parse')
              return { type: 'parse', op: 'neg', expr: val };
            return { type: val.type, val: -val.val };
          }
          parsepos = backtrack;
          return null;
        }
        return parseTerm();
      }

      // Parse a multiplicitive expression:
      //    unary [ '*' unary ]*
      //    unary [ '/' unary ]*

      function parseMulExpr() {
        const backtrack = parsepos;
        let val = parseUnary();
        if (val === null)
          return null;
        while (true) {
          if (take("*")) {
            let val2 = parseUnary();
            if (val2 === null) {
              parsepos = backtrack;
              return null;
            }
            if (val.type === 'fn' || val2.type === 'fn')
              throw "Can't multiply functions";
            if (val.type === 'parse' || val2.type === 'parse')
              return { type: 'parse', op: '*', expr1: val, expr2: val2 };
            if (val.type === 'num' && val2.type === 'num')
              val = { type: 'num', val: val.val * val2.val };
            else if (!(val.type === 'in' && val2.type === 'in'))
              val =  { type: 'in', val: val.val * val2.val };
            else
              throw "Cannot multiply lengths";
          } else if (take("/")) {
            let val2 = parseUnary();
            if (val2 === null) {
              parsepos = backtrack;
              return null;
            }
            if (val.type === 'fn' || val2.type === 'fn')
              throw "Can't divide functions";
            if (val.type === 'parse' || val2.type === 'parse')
              return { type: 'parse', op: '/', expr1: val, expr2: val2 };
            if (val2.val === 0) throw "Divide by zero";
            if (val.type === 'num' && val2.type === 'num')
              val =  { type: 'num', val: val.val / val2.val };
            else if (val.type === 'in' && val2.type === 'num')
              val =  { type: 'in', val: val.val / val2.val };
            else if (val.type === 'in' && val2.type === 'in')
              val =  { type: 'num', val: val.val / val2.val };
            else
              throw "Cannot divide numbers by lengths";
          } else {
            break;
          }
        }
        return val;
      }

      // Parse an (additive) expression:
      //    mulexpr [ '+' mulexpr ]*
      //    mulexpr [ '-' mulexpr ]*

      function parseExpr() {
        const backtrack = parsepos;
        let val = parseMulExpr();
        if (val === null)
          return null;
        while (true) {
          if (take("+")) {
            let val2 = parseMulExpr();
            if (val2 === null) {
              parsepos = backtrack;
              return null;
            }
            if (val.type === 'fn' || val2.type === 'fn')
              throw new ChattyError("Can't add functions");
            if (val.type === 'parse' || val2.type === 'parse')
              return { type: 'parse', op: '+', expr1: val, expr2: val2 };
            if (val.type === 'num' && val2.type === 'num')
              val = { type: 'num', val: val.val + val2.val };
            else if (val.type === 'in' && val2.type === 'in')
              val = { type: 'in', val: val.val + val2.val };
            else if (val.type === 'in' && val2.type === 'num' && val2.val === 0)
              {}   // special case for adding 0; take first val
            else if (val2.type === 'in' && val.type === 'num' && val.val === 0)
              val = val2;  // special case for adding 0; take second val
            else if (val.type === 'num')
              throw "Cannot add numbers and lengths";
            else if (val.type === 'in')
              throw new ChattyError("Cannot add numbers and lengths");
          } else if (take("-")) {
            let val2 = parseMulExpr();
            if (val2 === null) {
              parsepos = backtrack;
              return null;
            }
            if (val.type === 'fn' || val2.type === 'fn')
              throw "Can't subtract functions";
            if (val.type === 'parse' || val2.type === 'parse')
              return { type: 'parse', op: '-', expr1: val, expr2: val2 };
            if (val.type === 'num' && val2.type === 'num')
              val = { type: 'num', val: val.val - val2.val };
            else if (val.type === 'in' && val2.type === 'in')
              val = { type: 'in', val: val.val - val2.val };
            else if (val.type === 'in' && val2.type === 'num' && val2.val === 0)
              {}   // special case for subtracting 0; take first val
            else if (val2.type === 'in' && val.type === 'num' && val.val === 0)
              val = { type: 'in', val: -val2.val };  // special case for subtracting 0;
            else if (val.type === 'num')
              throw "Cannot subtract numbers and lengths";
            else if (val.type === 'in')
              throw new ChattyError("Cannot subtract numbers and lengths");
          } else {
            break;
          }
        }
        return val;
      }

      // Parse a statement:
      //    expr
      //    word '=' expr
      //    word '(' [ word [ ',' word ]* ]opt ')' '=' expr

      function parseStatement() {
        const backtrack = parsepos;
        let word = parseWord();
        if (word !== null) {
          if (take('=')) {
            let val = parseExpr();
            if (val) {
              return { ...val, sym: word, defined: true };
            }
          }
          if (take('(')) {
            let params = [];
            let param = parseWord();
            while (param !== null) {
              params.push(param);
              if (!take(','))
                break;
              param = parseWord();
            }
            if (take(')') && take('=')) {
              // make sure the parameters all have different names
              const paramNames = {};
              for (const p of params) {
                if (paramNames[p]) throw `duplicate parameter ${p} in function ${word}`;
                paramNames[p] = true;
              }
              const saveEnv = environment;
              try {
                environment = {};
                for (const p of params)
                  environment[p] = { type: 'parse', sym: p, defined: true };
                skipSpaces();
                const exprStart = parsepos;
                let expr = parseExpr();
                environment = saveEnv;
                if (expr !== null)
                  return { type: 'fn', expr: expr, sym: word, defined: true,
                           params: params, body: parsestr.substr(exprStart) };
               }
               catch (e) {
                 environment = saveEnv;
                 throw e;
               }
             }
           }
           parsepos = backtrack;
        }
        return parseExpr();
      }

      function updateParse(userHitEnter) {
        clearFields();
        try {
          parsestr = initialParseStr = document.getElementById('expr').value;
          parsepos = 0;
          parseFurthest = 0;
          environment = {};
          let val = parseStatement();
          skipSpaces();
          if (val !== null && !peekc()) { // nothing left over at the end
            if (userHitEnter && val.defined) {
              let sym = val.sym;
              if (symbols[sym]) throw "Cannot redefine system symbols";
              showAssignResult(val);
              delete val.defined;
              userSymbols[sym] = val;
              showUserSymbols();
            } else if (val.type === 'in') {
              showResult(val.val);
            } else if (val.type === 'num') {
              showNumberResult(val.val);
            } else if (val.type === 'fn' && !val.defined) {
              showAssignResult(val);
            }
            return;
          } else if (userHitEnter) {
            let rest = parsestr.substr(parseFurthest);
            if (rest.length > 0)
              throw `Cannot parse beyond "${rest}"`;
            else if (parsestr.trim() !== "")
              throw `Incomplete input`;
          }
        }
        catch (e) {
          showError(e, userHitEnter);
        }

        // Gray out the result since we can't parse correctly right now
        document.getElementById('results').style.color = '#aaaaaa';  
        document.getElementById('numberResults').style.color = '#aaaaaa';
      }

      function clearFields() {
        for (const field of ['ft', 'inch', 'num', 'times', 'div'])
          document.getElementById(field).value = "";
      }

      function showNumberResult(num) {
        document.getElementById('results').style.display = 'none';
        document.getElementById('numberResults').style.display = '';
        document.getElementById('error').style.display = 'none';
        document.getElementById('numberResults').style.color = '';

        document.getElementById('numberResultsDetail').textContent = num2str(num);
      }

      function escapeHTML(str) {
        return str
          .replace(/&/g, "&amp;")
          .replace(/</g, "&lt;")
          .replace(/>/g, "&gt;")
          .replace(/"/g, "&quot;")
          .replace(/'/g, "&#039;");
      }

      function showUserSymbols() {
        document.getElementById('symdefs');
        let str = "";
        // Kinda seems like sorting is a good idea, but
        // JavaScript keeps entries in definition order and
        // that's actually better
        for (const sym in userSymbols) {
          let symStr = symString(userSymbols[sym]);
          if (symStr)
            str += `<p class="defn"><span onclick="deleteDef('${sym}')">&times;</span>
              ${escapeHTML(symStr)}</p>`;
        }
        document.getElementById('symdefs').innerHTML = str;

        // Can't seem to save to local storage on unload in Safari,
        // so just do it here, I guess.
        saveUserSymbols();
      }

      function deleteDef(sym) {
        delete userSymbols[sym];
        showUserSymbols()
      }

      function symString(val) {
        if (val.type === 'in') {
          let [ftStr, inStr, delta] = inchesToStringReps(val.val);
          return `${val.sym} = ${ftStr}${delta}`;
        }
        if (val.type === 'num') {
          return `${val.sym} = ${val.val}`;
        }
        if (val.type === 'fn') {
          return `${val.sym}(${val.params.join(", ")}) = ${val.body}`;
        }
        return undefined;
      }

      function showAssignResult(val) {
        let str = symString(val);
        if (!str)
          return;
        document.getElementById('results').style.display = 'none';
        document.getElementById('numberResults').style.display = '';
        document.getElementById('error').style.display = 'none';
        document.getElementById('numberResults').style.color = '';
        document.getElementById('numberResultsDetail').textContent = str;
      }

      function showResult(totalInches, updateExpr) {
        document.getElementById('results').style.display = '';
        document.getElementById('numberResults').style.display = 'none';
        document.getElementById('error').style.display = 'none';
        document.getElementById('results').style.color = '';

        document.getElementById('resultIn').textContent = num2str(totalInches);
        document.getElementById('resultFt').textContent = num2str(totalInches/12);

        let [ftStr, inStr, delta] = inchesToStringReps(totalInches);
        document.getElementById('resultFtDetail').textContent = ftStr + delta;
        if (updateExpr)
          document.getElementById('expr').value = ftStr + delta;

        document.getElementById('resultInDetail').textContent = inStr + delta;

        // show metric for good measure
        document.getElementById('resultMeters').textContent =
          num2str(totalInches * 0.0254);
        document.getElementById('resultMetersMetricFeet').textContent =
          num2str(totalInches * 0.025);
      }

      function inchesToStringReps(totalInches) {
        let minus = "";
        if (totalInches < 0) {
          totalInches = -totalInches;
          minus = "-";
        }

        // Recover feet and inches from from result
        // (round to nearest 1/denom)
        let denom = 32;
        let inches =  ((totalInches*denom + 0.5)|0)/denom;
        let ft = (inches/12)|0;      // "n|0" truncates to an integer
        inches = inches - ft*12;
        let frac = inches - (inches|0);
        inches = inches|0;
        let num = (frac*denom)|0;
        while (denom > 2 && num%2 === 0) {  // reduce fraction
          denom = denom/2;
          num = num/2;
        }

        // format that string
        let ftStr = minus, sp = "";
        if (ft !== 0 || (inches === 0 && num === 0)) {
          ftStr += ft + "'";
          sp = " ";
        }
        if (inches !== 0) {
          ftStr += sp + inches;
          sp = " ";
        }
        if (num !== 0)
          ftStr += `${sp}${num}/${denom}`;
        if (inches !== 0 || num !== 0)
           ftStr += '"';
        let delta = totalInches - (ft*12 + inches + num/denom);
        if (Math.abs(delta) < EPSILON) {
          delta = "";
        } else {
          if (delta < 0)
            delta = ` - ${num2str(-delta)}"`;
          else
            delta = ` + ${num2str(delta)}"`;
        }
 
        // format inches
        let inStr = minus;
        sp = "";
        inches = ft*12 + inches;
        if (inches !== 0 || num === 0) {
          inStr += inches;
          sp = " ";
        }
        if (num !== 0)
          inStr += `${sp}${num}/${denom}`;
        inStr += '"';
        return [ftStr, inStr, delta];
      }

      function showHelp(id) {
        hideHelp();  // in case other help is already showing
        let helpElement = document.getElementById(id);
        helpElement.style.display = "block"; // inherits 'none' from "help" class
        for (let child of helpElement.children)
          if (child.tagName === 'DIV')
            child.scroll(0, 0);
      }

      function hideHelp() {
        let elts = document.querySelectorAll('.help');
        for (let e of elts)
          e.style.display = ''; // back to inherited 'none'
      }

      const GUID = "ad1f9c32-ed69-457d-89a0-f966c81424bd";
      const LOCAL_STORAGE_KEY = "FeetInchCalculator-" + GUID;
      const MAJOR = 1, MINOR = 0, PATCH = 0;

      function clearLocalStorage() {
        const localStorage = window.localStorage;
        if (!localStorage)
          return;
        localStorage.setItem(LOCAL_STORAGE_KEY, "");
        localStorage.clear();
      }

      function loadUserSymbols() {
        const localStorage = window.localStorage;
        if (!localStorage)
          return false;
        try {
          let json = localStorage.getItem(LOCAL_STORAGE_KEY);
          if (!json)
            return false;
          let wad = JSON.parse(json);
          if (!wad || !wad.major || wad.major > MAJOR)
            return false;
          if (!wad.defs)
            return false;
          for (const def of wad.defs) {
            try {
              // XXX refactor this?
              parsestr = initialParseStr = def;
              parsepos = 0;
              parseFurthest = 0;
              environment = {};
              let val = parseStatement();
              skipSpaces();
              if (val !== null && !peekc()) { // nothing left over at the end
                let sym = val.sym;
                if (symbols[sym])
                  next;
                delete val.defined;
                userSymbols[sym] = val;
              }
            }
            catch (e) {
            }
          }
          showUserSymbols();
          return true;
        }
        catch (e) {
        }
        return false;    
      }

      function saveUserSymbols() {
        const localStorage = window.localStorage;
        if (!localStorage)
          return false;
        const wad = {
          major: MAJOR, minor: MINOR, patch: PATCH, defs: []
        };
        // We rely on the fact that objects are enumerated in the order
        // items were added. Otherwise, function definitions might fail
        // due to their variable references being unsatisfied.
        for (const sym in userSymbols) {
          let symStr = symString(userSymbols[sym]);
          if (symStr)
            wad.defs.push(symStr);
        }
        let json = JSON.stringify(wad);
        try {
          localStorage.setItem(LOCAL_STORAGE_KEY, json);
          return true;
        }
        catch (e) {
        }
        return false;
      }

      function addExampleStuffs() {
        let elements = document.querySelectorAll(".help table.example td:first-child, .help code");
        for (let e of elements) {
          e.addEventListener("click", function() {
            document.getElementById('expr').value = this.textContent.trim();
            updateParse(true);
          });
        }
      }

      document.addEventListener("keydown", function(evt) {
        evt = evt || window.event;
        if (evt.key === "Escape" || evt.key === "Esc" || evt.keyCode === 27)
          hideHelp();
      });

      function onLoad() {
        loadUserSymbols();
        updateResult();
        addExampleStuffs();
      }

    </script>
  </body>
</html>