<!--
  Copyright 2021 Stan Switzer

    This work is licensed under a Creative Commons Attribution-ShareAlike
    4.0 International License. https://creativecommons.org/licenses/by-sa/4.0/

  Synopsis:

    A simple tool for doing calculations with US customary units
    of length.
-->
<html>
  <head>
    <title>Feet & Inch Calculator</title>
    <base target="_blank"> <!-- all links open in a new tab/page -->
    <style type="text/css">
      body {
        padding: 4px 12px;
        box-sizing: border-box;
        margin: 0px 8px;
        font-family: caption, sans-serif;
        font-size: 12pt;
        background-color: #f8f8f8;
      }

      /* Spiff up input fields */
      input[type="text"] {
        font-size: 13pt;
        border-radius: 5px;
        padding: 1px 4px;
      }

      /*
       * Layout containers
       */
      div.layout-column {
        display: flex;
        flex-flow: column nowrap;
      }
      div.layout-column > div {
        margin: 4px 0px;
      }
      body > div.layout-column {
        height: 100%;
      }
      div.layout-row {
        display: flex;
        flex-flow: row nowrap;
        flex: 0 0 auto;
      }
      div.expands {
        /* https://geon.github.io/programming/2016/02/24/flexbox-full-page-web-app-layout */
        flex: 1 1 auto;
        overflow: hidden;
      }
      div.shrink-wrap {
        width: min-content;
      }
      div.force-width {
        width: max-content;
      }

      /*
       * Initially-hidden help content.
       * Help contains a <span class="close-button"> for a close button
       * and a <div> for help content which is made scrollable.
       */
      div.help {
        padding: 0px 4px 0px 20px;
        background-color: #e8e8e8;
        position: absolute;
        display: none;
        top: 10%;
        left: 25%;
        right: 16px;
        bottom: 16px;
        border: 2px solid black;
      }
      div.help > span.close-button {
        color: #888888;
        font-weight: bold;
        float: right;
        font-size: 40px;
        cursor: pointer;
        transition: 0.3s;
      }
      div.help > span.close-button:before {
        content: "\d7"; /* Unicode times character */
      }
      div.help > span.close-button:hover {
        transform: scale(1.25);
        color: black;
      }
      div.help > span.close-button:active {
        transform: scale(1.5);
      }
      div.help > div {
        overflow-y: auto;
        height: 100%;
      }
      /* styling for help content */
      div.help td, div.help th {
        padding: 0em .15em;
        vertical-align: top;
        text-align: left;
      }
      div.help ul {
        padding-left: 1.25em;
      }
      div.help ul > li {
        margin: .5em;
      }
      div.help code {
        font-weight: bold;
      } 
      div.help code.abstract {
        font-style: italic;
      }
      div.help table.example tr td:first-child {
        width: 7em;
      }
      div.help table.example2 tr td:nth-child(1),
      div.help table.example2 tr td:nth-child(2) {
        width: 3em;
      }
      div.help table.example, div.help table.example2 {
        margin-left: 1em;
      }
      /* Testing affordance; example text can be stuffed into the expr box */
      div.help code:hover,
      div.help table.stuff.example tr td:first-child:hover,
      div.help table.stuff.example2 tr td:nth-child(1):hover,
      div.help table.stuff.example2 tr td:nth-child(2):hover {
        cursor: pointer;
        color: #0000dd;
        text-decoration: underline;
        --click-action: stuff-text
      }

      /*
       * Makes a <span> into a "button"
       */
      span.button {
        display: inline-block;
        cursor: pointer;
        padding: 2px 8px;
        background: #4444ff;
        border-radius: 5px;
        color: white;
        transition: 0.3s;
      }
      span.button:hover {
        background: #0000dd;
        /* transform: scale(1.15); */
      }
      span.button:active {
        background: #0000cc;
        /* transform: scale(1.3); */
      }

      /* Looks like a link but is actually a "button" */
      span.linklike {
        color: #0000dd;
        cursor: pointer;
        text-decoration: underline;
      }

      /*
       * Animates the delete button for variable and function definitions
       */
      p.user-def {
        margin: .25em 0em;
      }
      p.user-def > span.delete-button:hover {
        background: #ff3333;
        /* transform: scale(1.15); */
      }
      p.user-def > span.delete-button:active {
        background: #ff0000;
        /* transform: scale(1.3); */
      }
      p.user-def > span.delete-button {
        display: inline-block; /* so that transform works */
        cursor: pointer;
        padding: 0em .25em;
        background: #ff7777;
        font-weight: bold;
        border-radius: 5px;
        color: white;
        transition: 0.1s;     
        visibility: hidden;
      }
      p.user-def > span.delete-button:before {
        content: "\d7"; /* Unicode times character */
        /*
         * What follows is a fudge to raise the baseline slightly;
         * "times" is apparently designed to match lower-case characters.
         */
        position: relative;
        top: -0.06em;
      }
      p.user-def:hover > span.delete-button {
        visibility: visible;
      }

      /*
       * User symbol defs take the remaining space and scroll
       */
      div.sym-defs {
        flex: 1 1 auto;
        overflow: auto;
        max-height:100%;
      }

      /* The results box */
      div.results {
        border: 2px solid;
        margin: 12px 0px;
        padding: 0px 12px;
        border-radius: 5px;
        font-size: 13pt;
      }
    </style>
  </head>
  <body>
    <div class="layout-column shrink-wrap">
      <div class="force-width">
        <input type="text" style="text-align: right;"
          oninput="updateResult()" size="4" id="ft" value="5"> feet &nbsp;
        <input type="text" style="text-align: right;"
          oninput="updateResult()" size="2" id="inch" value="">
        <sup>
          <input type="text" style="text-align: right;"
            oninput="updateResult()" size="2" align="right" id="num" value="">
        </sup>/<sub>
          <input type="text" oninput="updateResult()" size="2" id="denom" value="8">
        </sub> inches
        &nbsp;&nbsp; times
        <input type="text" oninput="updateResult()" size="3" id="times" value="">
        &nbsp; divided by
        <input type="text" oninput="updateResult()" size="3" id="div" value="">
      </div>
      <div class="layout-row">
        <div class="expands">
          <input style="width: 100%;" type="text" spellcheck="false" id="expr" value=""
            oninput="updateParse()" onchange="updateParse(true)">
        </div>
        <span class="button" style="margin-left: .25em; font-size: 1.125em"
          onclick="showHelp('help-expr')">?</span>
      </div>
      <div class="results">
        <p id="results">
          <span id="resultFt"></span> feet = <span id="resultFtDetail"></span>
          <br>
          <span id="resultIn"></span> inches = <span id="resultInDetail"></span>
          <br>
          <span id="resultMeters"></span> meters
          <br>
          <span id="resultMetersMetricFeet"></span> meters (assuming "metric feet")
        </p>
        <p id="numberResults">
          <span id="numberResultsDetail"></span>
        </p>
        <p id="error" style="color: red"></p>
      </div>
      <div class="layout-row expands">
        <div class="sym-defs" id="symdefs"></div>
        <div><span class="button" onclick="showHelp('help-tips')">Help</span></div>
      </div>
    </div>
    <div class="help" id="help-tips">
      <span class="close-button" onclick="showHelp()"></span>
      <div>
        <h2> Help </h2>
        <p> Some quick tips to get you started:
        <ul>
          <li> Input boxes can be left empty when not relevent.
          <li> A value like five and a half feet can be entered as 5.5 feet or as 5 feet 6 inches.
          <li> A value like six and a quarter inches can be entered as 6.25 inches or
               as 6 inches and 1/4.
          <li> A "metric foot" is a convention used by the construction industry in metric
               countries where a foot is taken to be exactly 30cm instead of 30.48cm. It's an
               <a href="https://en.wikipedia.org/wiki/ISO_2848#Metric_foot">
                 international standard</a>!
          <li> In the "help" boxes, most sample expressions can be clicked to evaluate
               the expression.
          <li> You can type a fairly general expression into the text box. Click the
               <span class="button" onclick="showHelp('help-expr')">?</span> button
               for more information.
        </ul>
      </div>
    </div>
    <div class="help" id="help-expr">
      <span class="close-button" onclick="showHelp()"></span> 
      <div>
        <h2> Expressions </h2>
        <p> Expressions can contain numbers, units and the operators
            <code>+</code> <code>-</code> <code>*</code> <code>/</code>
            and <code>^</code> (exponentiation).
            Multiplication and division are performed before addition and subtraction, and
            parenthesis can be used for grouping. Spaces are generally optional.
        <p> Units include:
            <code>ft</code> <code>'</code> <code>in</code> <code>"</code> 
            <code>m</code> and <code>cm</code>.
        <p> As you type, the expression might be momentarily unparsable, e.g.,
            "<code>3'+</code>", until you finish typing. 
            The results box will be grayed out while that happens.
            It would be too noisy to alert each of these errors, but if you don't 
            know why it's grayed out, you can hit enter to see an error message.
        </p>
        <table class="stuff example">
          <tr>
            <th> Example
            <th> Description
          <tr>
            <td> 5' 6"
            <td> An ordinary distance
          <tr>
            <td> 5' 6 3/8" / 3
            <td> Divide 5 feet 6 and 3/8 inches by 3
          <tr>
            <td> 5 1/2' - 8"
            <td> Subtracts lengths
          <tr>
            <td> 5.5'
            <td> You can use decimal values instead of fractions
          <tr>
            <td> 3/4"
            <td> You can use just a fraction
          <tr>
            <td> (5'6" + 7') / 2
            <td> The average of 5'6" and 7'
          <tr>
            <td> 5'10 3/8" * 3/4
            <td> 3/4 of 5' 10 3/8"
          <tr>
            <td> 12' / 6"
            <td> The ratio of 12' and 6" (result is 24)
          <tr>
            <td> 1 + 2 * 3
            <td> Ordinary math (note order of operations; result is 7)
          <tr>
            <td> (1 + 2) * 3
            <td> Result is 9
          <tr>
            <td> 1m - 2cm
            <td> One meter minus two centimeters
         <tr>
            <td> ft
            <td> A foot
          <tr>
            <td> ft * 8
            <td> 8 feet; notice that named units are simply variables that have units
          <tr>
            <td> 5' 6" * pi
            <td> Circumference of a 5' 6" diameter circle
          <tr>
            <td> hyp(3', 4')
            <td> Hypotenuse of a right triangle with sides 3' and 4' (result is 5')
          <tr>
            <td> 1/4 mi2 / acre
            <td> The number of acres in a quarter of a square mile
        </table>
        <h2> Terms </h2>
        <p> Expressions are built up out of <i>terms</i> which are either
          <ul>
            <li> A plain number such as <code>12</code>, <code>7.</code>,
                 <code>3.14</code>, <code>.15</code>, etc.
            <li> A variable name, such as <code>pi</code>
            <li> A <i>length</i> which can be a number, a fraction, or a number
                 and a fraction followed buy a <i>unit</i>
            <li> Any sequence of the the previous length-unit combinations as long as
                 the units are of descending size
          </ul>
        <h3> Units </h3>
        <p> Units are either the notations <code>'</code> and <code>"</code> for
            feet and inches or these named units:
        </p>
        <table class="stuff example">
          <tr>
            <th> Unit
            <th> Description
          <tr>
            <td> in
            <td> Inch
          <tr>
            <td> ft
            <td> Foot
          <tr>
            <td> yd
            <td> Yard
          <tr>
            <td> mi
            <td> Mile
          <tr>
            <td> acre
            <td> Acre
          <tr>
            <td> mm
            <td> Millimeter
          <tr>
            <td> cm
            <td> Centimeter
          <tr>
            <td> m
            <td> Meter
          <tr>
            <td> km
            <td> Kilometer
          <tr>
            <td> hectare
            <td> Hectare, or <code>100m &times; 100m</code>
          <tr>
            <td> litre
            <td> A volume of <code>10cm &times; 10 cm &times; 10 cm</code>.
        </table>
        <p> Other less common units are also defined.
            To learn more, you can either
            <a href="https://gist.github.com/sjswitzer/77288511a213dd0d973d99a941ac909e">read the code</a>
            or <span class="linklike" onclick="showHelp('help-builtin')">this summary</span>.
        <p> Any <i>variable</i> you define with a unit can be used as
            a unit itself.
            For example, if you enter <code>cubit = 1 1/2'</code>, you can then use
            expressions like <code>3 cubit 5 1/2"</code>.
        <p> A unit can be immediately followed (without spaces) by a number which is
            the power of that unit. For instance, <code>3 yd2</code> is three square yards
            (27 square feet)
            and <code>2 ft3</code> is two cubic feet. If a unit specifier is immediately
            preceded by a <code>/</code> (without spaces), it is an inverse unit.
            For instance, <code>60 /ft2</code> means 60 per square foot.
            <code>144/ft2</code> means 144 per square foot or, equivalently, 1 per square inch
            (which is how it will display). <i>What</i> per square foot? Anything. Think "ducks" and
            you'll be on the right track.
        <p> Units must be specified in descending order.
            You can use <code>12'3"</code> but you can't use <code>12"3'</code>.
            This is to prevent accidentally typing <code>12'3'</code> when you really
            meant <code>12'3"</code>.
            You can type nonsense like <code>3 1/2m 3.5"</code> if you want, but you won't
            do it by accident.
        <p><i>Beware that spaces can occasionally make a big difference.</i>
            <code>1/2 in</code> or <code>1/2in</code> means half an inch,
            but <code>1 / 2 in</code> or even
            <code>1/ 2 in</code> means one over 2 inches. Just avoid putting spaces around
            the slash in a fractional unit and you'll be fine.
        <h2> Variables </h2>
        <p> Define variables by typing <code class="abstract">name = expression</code>
            then hitting "enter."
            For instance, <code>frontage = 45'4 3/4"</code>. You can then use those values
            in later expressions, e.g. <code>frontage/3</code>.
            Amusingly, perhaps, because <code>frontage</code> is a length, it can also be
            used as a unit: <code>1/3 frontage</code> or <code>1/3frontage</code>.
        <p> The variables <code>ft</code>, <code>in</code>, <code>m</code>, <code>cm</code>,
            etc. described in "Units" above
            are predefined for use as values or as units. The variable <code>pi</code> is
            predefined in case you care about circles.
            <span class="linklike" onclick="showHelp('help-builtin')">Reserved</span>
            predefined variables cannot be changed.
        <h2> Functions </h2>
        <p> Define functions to automate routine calculations by typing
            <code class="abstract">name(param,param,&hellip;) = expression</code>
            then hitting "enter." For instance, you can define a function to average to numbers
            or lengths: <code>average(x,y) = (x+y)/2</code> (but the predefined function
            <code>mean(&hellip;)</code> already does that, so&hellip;).
        <p> Function bodies can use any of their parameters (<i>of course</i>) and variables
            that have already been defined. As a special case, a function with no parameters
            can be used as a "dynamic variable." That is, assuming variables <code>a</code>
            and <code>b</code> are already defined, the function
            <code>c() = a + b</code> can be invoked as <code>c()</code> or <code>c</code>,
            and in either case gives you the current value of <code>a + b</code>.
        <h3> Built-In Functions </h3>
        <table class="example">
          <tr>
            <th> Function
            <th> Description
          <tr>
            <td> mean(x,y,&hellip;) 
            <td> The average of a set of numbers or lengths
          <tr>
            <td> hyp(x,y,&hellip;) 
            <td> The hypotenuse of a triangle or, more usefully, the diagonal of a rectangle
          <tr>
            <td> sqrt(x) 
            <td> Square root
          <tr>
            <td> cbrt(x) 
            <td> Cube root
        </table>
        <h2> Saved State </h2>
        <p> User-defined variables and functions are saved between sessions in local
            storage.
        <h2> Odds And Ends </h2>
        <p> <span class="linklike" onclick="showHelp('help-boring')">Boring details</span>
            if you're interested.
      </div>
    </div>
    <div class="help" id="help-boring">
      <span class="close-button" onclick="showHelp()"></span>
      <div>
        <h2> Boring Details </h2>
        <p> This program started out as a quick and dirty tool to easily divide
            lengths given in feet and inches into equal parts, a common task
            in the construction industry and quite tedious to work out by hand.
            The vestiges of that are seen in the top line of the current
            user interface.
        <p> But I started to think of it as a <i>calculator</i> and wondered
            if it could be generalized to do arbitrary math with lengths. The result
            is what you see here. It's not clear how useful any of that functionality
            is but it was a good excuse to tinker.
        <p> It's possible to add two lengths,
            resulting in another length, or to multiply or divide a length by a number.
            But you can't add a length and a number.
            You can divide a length by a length to get a number (the ratio of lenghts).
            Can you multiply two lengths? Yes, but the result is an <i>area</i>.
        <p> This line of thinking leads to
            <a href="https://en.wikipedia.org/wiki/Dimensional_analysis">dimensional analysis</a>,
            and there are already some very good programs out there for that including the
            legendary
            <a href="https://linux.die.net/man/1/units">Unix "units" command</a>.
            Hell, <a href="https://www.google.com/search?q=12+acres+%2F+100+feet">
            Google will do it for you</a> if you ask it nicely. This program
            does a limited amount of dimensional analysis over a range of familiar units.
        <p> The main distinction of this tool is that it deals naturally with notations
            typically used with feet and inches. But, <i>sigh</i>,
            <a href="https://www.google.com/search?q=5%27+6+3%2F8%22+%2F+3">
            Google will do that for you too</a>.
        <p> Oh well, it was a good excuse to spiff up my HTML, CSS, and JavaScript skills.
            Not a bad weekend project that got out of hand.
        <p> A-B-C. A-Always. B-Be. C-Coding.
        <p> Copyright &copy; 2021, Stan Switzer
        <div style="float: left; margin: 0em .5em 4.5em 0em">
          <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">
            <img alt="Creative Commons License" style="border-width:0"
              src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png">
          </a>
        </div>
        <p> This work is licensed under a
          <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">
            Creative Commons Attribution-ShareAlike 4.0 International License
          </a>.
        <br> Find source on
          <a href="https://gist.github.com/sjswitzer/77288511a213dd0d973d99a941ac909e">GitHub</a>
      </div>
    </div>
    <div class="help" id="help-builtin">
      <span class="close-button" onclick="showHelp()"></span>
      <div>
        <h2> Built-In Constants and Units </h2>
        <p> This table is generated automaticaly from internal system data.
            It may not be pretty, but it is comprehensive.
        <p> Symbols that are reserved (cannot be redefined) are noted.
        <p>
        <table class="stuff example2">
          <thead>
            <tr>
              <th> Symbol
              <th> Inverse
              <th> Description
            </tr>
          </thead>
          <tbody id="builtin-symbols">
          </tbody>
        </table>
      </div>
    </div>
    <script type="text/javascript">
      "use strict";

      // Errors that are too chatty to show while typing.
      //   (Error will be shown if the user hits "enter.")
      class ChattyError extends Error {
        constructor(msg) {
          super();
          this.message = msg;
        }
      }

      class Dim {
        static isScalar(dim) {
          if (!dim)
            return true;
          for (const measure in dim)
            if (dim[measure] != 0)
              return false;
          return true;
        }

        static basis(dim) {
          let res = null;
          for (const measure in dim)
            if (dim[measure] !== 0) {
              if (res)
                return null;
              res = measure;
            }
          return res;
        }

        static equal(dim1 = {}, dim2 = {}) {
          for (const measure in dim1) {
            if ((dim1[measure]??0) !== (dim2[measure]??0))
              return false;
          }
          for (const measure in dim2)
            if ((dim1[measure]??0) !== (dim2[measure]??0))
              return false;
          return true;
        }

        static mul(dim = {}, n) {
          let ret = {};
          for (const measure in dim)
            ret[measure] = dim[measure]*n;
          return ret;
        }

        // If a dimension can be evenly divided, the new dimension, else null
        // We don't do fractal dimensions here.
        static div(dim = {}, n) { 
        let ret = {};
          for (const measure in dim) {
            const expDiv = dim[measure]/n;
            if (expDiv !== Math.trunc(expDiv))
              return null;
            ret[measure] = expDiv;
          }
          return ret;
        }

        static reduce(dim1, dim2) {
          // If dim1 can be reduced by a power of dim2,
          // returns [ exp, reducedDim]. Exp is zero if not reduced.
          // Dimensions are reduced if at least one dimension can be
          // reduced to zero exponent. Partial reductions are not
          // allowed or you end up with things like hectare kilometers.
          let measures = {}, ret = {}, reduced = false;
          for (const measure in dim1)
            measures[measure] = true;
          for (const measure in dim2)
            measures[measure] = true;
          let exp = 0;
          for (const measure in measures) {
            let exp1 = dim1[measure]??0, exp2 = dim2[measure]??0;
            if (exp2 === 0) {
              ret[measure] = exp1;
              continue;
            }
            let thisExp = exp1/exp2;
            if (thisExp !== Math.trunc(thisExp))
              return [ 0, {} ];
            if (exp && exp !== thisExp)
              return [ 0, {} ];
            exp = thisExp;
            ret[measure] = 0;
          }
          return [ exp, ret ];
        }

        static add(dim1 = {}, dim2 ={}, factor = 1) {
          let measures = {}, ret = {};
          for (const measure in dim1)
            measures[measure] = true;
          for (const measure in dim2)
            measures[measure] = true;
          for (const measure in measures) {
            if (!dim1[measure])
              ret[measure] = factor * dim2[measure];
            else if (!dim2[measure])
              ret[measure] = dim1[measure];
            else
              ret[measure] = dim1[measure] + factor * dim2[measure];
          }
          return ret;
        }

        static sub(dim1, dim2, factor = 1) {
          return Dim.add(dim1, dim2, -factor);
        }
      }

      // A curious thing worth noting: It turns out that fractions of the form
      // "n / power-of-2" are precicely the values that can be represented exactly
      // in floating point arithmetic and also the conventional way of expressing
      // fractional inches. So doing all arithmetic in units of inches means that
      // calculations can be exact when exact results are possible.
      //
      // It later occurred to me that doing calculations in metric units of a
      // hundredth of a centimeter or less would lead to exact results for both systems
      // most often. The largest SI unit that would serve is the micrometer.
      // But why not go further? Decimal fractions suffer in binary
      // representations. Many exact values in decimal must be approximated in binary.
      // But if you pick a small enough base unit, all integral values greater that
      // can be exact. 
      //
      // If an expression contains any US units, the results will be displayed in
      // those units. If an expression contains only metric units, the results
      // will be displayed in metric.

      const UM = 1000, MM = 1000*UM, CM = 10*MM, M  = 1000*MM, KM = 1000*M;
      const IN = 25400*UM, FT = 12*IN;

      const SEC = 1, MIN = 60*SEC, HR = 60*MIN; 
      const GM = 1000, KG = 1000*GM;
      const LBF = 4.448222*KG*M/(SEC*SEC);

      const systemSymbols = {
        // Length (L)
        in: { type: 'num', dim: { L: 1 }, val: IN, desc: "inch", reserved: true, uscu: true },
        ft: { type: 'num', dim: { L: 1 }, val: FT, desc: "foot", reserved: true, uscu: true },
        yd: { type: 'num', dim: { L: 1 }, val: 3*FT, desc: "yard", uscu: true },
        link: { type: 'num', dim: { L: 1 }, val: 66*FT/100, desc: "surveyor's link", uscu: true },
        rod: { type: 'num', dim: { L: 1 }, val: 66*FT/4, desc: "surveyor's rod", uscu: true },
        chain: { type: 'num', dim: { L: 1 }, val: 66*FT, desc: "surveyor's chain", uscu: true },
        furlong: { type: 'num', dim: { L: 1 }, val: 660*FT, uscu: true },
        mi: { type: 'num', dim: { L: 1 }, val: 5280*FT, desc: "mile", reserved: true, uscu: true },
        mm: { type: 'num', dim: { L: 1 }, val: MM, desc: "millimeter", reserved: true },
        cm: { type: 'num', dim: { L: 1 }, val: CM, desc: "centimeter", reserved: true },
        m:  { type: 'num', dim: { L: 1 }, val: M, desc: "meter", reserved: true },
        km: { type: 'num', dim: { L: 1 }, val: KM, desc: "kilometer", reserved: true },

        // Area (L^2)
        acre: { type: 'num', dim: { L: 2 }, val:  66*FT * 660*FT, reserved: true, uscu: true },
        hectare: { type: 'num', dim: { L: 2 }, val: (100*M)**2, desc: "100 meters \u00D7 100 meters" },
        are: { type: 'num', dim: { L: 2 }, val: (10*M)**2, desc: "10 meters \u00D7 10 meters" },

        // Volume (L^3)
        gallon : { type: 'num', dim: { L: 3 }, val: 231*IN**3, uscu: true },
        quart : { type: 'num', dim: { L: 3 }, val: 231*IN**3/4, uscu: true },
        pint : { type: 'num', dim: { L: 3 }, val: 231*IN**3/8, uscu: true },
        cup : { type: 'num', dim: { L: 3 }, val: 231*IN**3/16, uscu: true },
        floz : { type: 'num', dim: { L: 3 }, val: 231*IN**3/128, desc: "fluid ounce", uscu: true },
        tbsp : { type: 'num', dim: { L: 3 }, val: 231*IN**3/256, desc: "tablespoon", uscu: true },
        tsp : { type: 'num', dim: { L: 3 }, val: 231*IN**3/768, desc: "teaspoon", uscu: true },
        litre : { type: 'num', dim: { L: 3 }, val: (10*CM)**3 },
        liter : { type: 'num', dim: { L: 3 }, val: (10*CM)**3 },
        ml : { type: 'num', dim: { L: 3 }, val: (CM)**3, desc: "milliliter" },
        cc : { type: 'num', dim: { L: 3 }, val: (CM)**3, desc: "cubic centimeter" },

        // Time (T)
        s: { type: 'num', dim: { T: 1 }, val: SEC, desc: "second", uscu: null },
        min: { type: 'num', dim: { T: 1 }, val: MIN, desc: "minute", uscu: true },
        hr: { type: 'num', dim: { T: 1 }, val: HR, desc: "hour", uscu: true },
        day: { type: 'num', dim: { T: 1 }, val: 24*HR, uscu: true },
        week: { type: 'num', dim: { T: 1 }, val: 24*7*HR, desc: "7 days", uscu: true },
        fortnight: { type: 'num', dim: { T: 1 }, val: 24*14*HR, desc: "2 weeks", uscu: true },

        // Mass (M)
        lb: { type: 'num', dim: { M: 1 }, val: 453.59237*GM, desc: "pound mass", uscu: true },
        oz: { type: 'num', dim: { M: 1 }, val: 453.59237/16*GM, desc: "ounce mass", uscu: true },
        gm: { type: 'num', dim: { M: 1 }, val: GM, desc: "gram" },
        kg: { type: 'num', dim: { M: 1 }, val: KG, desc: "kilogram" },
        dalton: { type: 'num', dim: { M: 1 }, val: 1.6605390666e-27*KG },

        // Force (L M T^-2)
        N: { type: 'num', dim: { L: 1, M: 1, T:-2 }, val: KG*M/(SEC*SEC), desc: "newton" },
        dyne: { type: 'num', dim: { L: 1, M: 1, T:-2 }, val: KG*M/(SEC*SEC)/100000 },
        lbf: { type: 'num', dim: { L: 1, M: 1, T:-2 }, val: LBF, desc: "pound force", uscu: true },

        // Energy (L^2 M, T^-2)
        joule: { type: 'num', dim: { L: 2, M: 1, T:-2 }, val: KG*M*M/(SEC*SEC) },
        erg: { type: 'num', dim: { L: 2, M: 1, T:-2 }, val: KG*M*M/(SEC*SEC)/10000000 },

        // Power (L^2 M T^-3)
        W: { type: 'num', dim: { L: 2, M: 1, T:-3 }, val: KG*M*M/(SEC*SEC*SEC), desc: "watt" },
        kW: { type: 'num', dim: { L: 2, M: 1, T:-3 }, val: 1000*KG*M*M/(SEC*SEC*SEC), desc: "kilowatt" },
        horsepower: { type: 'num', dim: { L: 2, M: 1, T:-3 }, val: 550*FT*LBF/SEC, desc: "mechanical horsepower", uscu: true },

        // Pressure (L^-1 M T^-2)
        Pa: { type: 'num', dim: { L: -1, M: 1, T:-2 }, val: KG/(M*SEC*SEC), desc: "pascal" },
        kPa: { type: 'num', dim: { L: -1, M: 1, T:-2 }, val: 1000*KG/(M*SEC*SEC), desc: "kilopascal" },
        PSI: { type: 'num', dim: { L: -1, M: 1, T:-2 }, val: LBF/(IN*IN), desc: "pounds per square inch", uscu: true },
        atm: { type: 'num', dim: { L: -1, M: 1, T:-2 }, val: 101325*KG/(M*SEC*SEC), desc: "atmosphere" },
        bar: { type: 'num', dim: { L: -1, M: 1, T:-2 }, val: 100000*KG/(M*SEC*SEC) },

        // Interesting constants (various)
        pi: { type: 'num', val: Math.PI },
        mol: { type: 'num', val: 6.02214076e23, desc: "Avogadro's number" },
        g: { type: 'num', dim: { L: 1, T:-2 }, val: 9.80665*M/(SEC*SEC)/10000000, desc: "standard gravity"},
        c: { type: 'num', dim: { L: 1, T:-1 }, val: 299792458*M/SEC, desc: "speed of light"},

        // General n-dimensional hypotenuse
        hyp: function Hypotenuse(...params) {
          if (params.length < 1)	
            return { type: 'num', dim: {}, val: 0 };
          let val = params.pop();
          let dim = val.dim;
          let uscu = val.uscu;
          let accum = 0;
          while (true) {
            if (val.val !== 0) {
              if (val.type !== 'num') throw `${this.sym}(x): Illegal parameter`;
              if (!Dim.equal(val.dim, dim))
                if (accum !== 0) throw `${this.sym}(): Parameter types incompatible`;
              accum += val.val * val.val;
              if (val.uscu)
                uscu = true;
            }
            val = params.pop();
            if (!val)
              break;
          }
          return { type: 'num', dim, val: Math.sqrt(accum), uscu };
        },

        // Square root
        sqrt: function SquareRoot(...params) {
          if (params.length !== 1) throw `${this.sym}(): Needs one parameter`;
          let val = params[0];
          if (val.type !== 'num') throw `${this.sym}(x): Illegal parameter`;
          let newDim = Dim.div(val.dim, 2);
          if (!newDim) throw `${this.sym}(x): parameter must have even units`;
          return { type: 'num', dim: newDim, val: Math.sqrt(val.val), uscu: val.uscu };
        },

        // Cube root
        cbrt: function CubeRoot(...params) {
          if (params.length !== 1) throw `${this.sym}(): Needs one parameter`;
          let val = params[0];
          if (val.type !== 'num') throw `${this.sym}(x): Illegal parameter`;
          let newDim = Dim.div(val.dim, 3);
          if (!newDim) throw `${this.sym}(x): parameter must have even units`;
          return { type: 'num', dim: newDim, val: Math.cbrt(val.val), uscu: val.uscu };
        },

        mean: function(...params) {
          if (params.length < 1) throw `${this.sym}(): No parameters`;
          let val = params.pop();
          let dim = val.dim;
          let uscu = val.uscu;
          let accum = 0, n = 0;
          while (true) {
            if (val.type !== 'num') throw `${this.sym}(x): Illegal parameter`;
            if (val.val === 0) {
              n += 1;
            } else {
              if (!Dim.equal(val.dim, dim))
                if (accum !== 0) throw `${this.sym}(): Parameter types incompatible`;
              accum += val.val;
              n += 1;
              if (val.uscu)
                uscu = true;
            }
            val = params.pop();
            if (!val)
              break;
          }
          return { type: 'num', dim, val: accum/n, uscu };
        },

        // Force metric units
        Metric: function ForceMetricUnits(...params) {
          if (params.length !== 1) throw `${this.sym}(): Needs one parameter`;
          let val = params[0];
          if (val.type !== 'num') throw `${this.sym}(x): Illegal parameter`;
          return { ...val, uscu: false };
        },

        // Force US Customary Units
        US: function ForceUSCustomaryUnits(...params) {
          if (params.length !== 1) throw `${this.sym}(): Needs one parameter`;
          let val = params[0];
          if (val.type !== 'num') throw `${this.sym}(x): illegal parameter`;
          return { ...val, uscu: true };
        },
      };

      const userSymbols = {};
      let environment = {};

      function getSymbol(symName) {
        let val = environment[symName];
        if (val === undefined)
          val = userSymbols[symName];
        if (val === undefined)
          val = systemSymbols[symName];
        if (val instanceof Function)
          val = { type: 'fn',  params:["..."], native: val,
            body: `#BuiltinFunction-${val.name}#` };
        if (!val) {
          // special case to create pseudo-variables for exponentiated units
          const match = /^([a-z]+)([0-9]+)$/i.exec(symName);
          if (match) {
            let val2 = getSymbol(match[1]);
            let exp = Number(match[2]);
            if (val2 && val2.type === 'num' && !Dim.isScalar(val2.dim) && val2.dim && exp > 1) {
              let desc = val2.desc && `${val2.desc ?? match[1]}^${String(exp)}`;
              return { sym: symName, type: 'num', dim: Dim.mul(val2.dim, exp), val: Math.pow(val2.val, exp),
                desc, reserved: val2.reserved, uscu: val2.uscu };
            }
          }
        }
        if (val && !val.sym)
          val.sym = symName;
        return val;
      }

      function invokeFunction(symVal, params) {
        if (symVal.type !== 'fn') throw "Not a function";
        if (symVal.native)
          return symVal.native(...params);   // symVal is "this" in a native function
        if (params.length !== symVal.params.length)
           throw new ChattyError(`incorrect number of params for ${symVal.sym}(${symVal.params.join(',')})`);
        const saveEnv = environment, saveParseStr = parseStr, saveParsePos = parsePos;
        try {
          parseStr = symVal.body;
          parsePos = 0;
          environment = {};
          for (const i in params)
            environment[symVal.params[i]] = params[i];
          let val = parseExpr();
          skipSpaces();
          if (peekc()) throw "Invalid function";
          return val;
        }
        finally {
          environment = saveEnv;
          parseStr = saveParseStr;
          parsePos = saveParsePos;
        }
      }

      //
      // Simple interface for common operations
      //

      function getField(name, def) {
        document.getElementById(name).style.color = '';
        let val = document.getElementById(name).value.trim();
        if (val === "") return def;
        val = parseFloat(val);
        if (isNaN(val) || (val === 0 && def !== 0))
          document.getElementById(name).style.color = 'red';
        return val;
      }

      const DIGITS_PRECISION = 10, EPSILON = Math.pow(10, -DIGITS_PRECISION);

      const candidateUnits = [
        'N',
        'in', 'ft', 'mi', 'acre',
        'tsp', 'tbsp', 'cup', 'pint', 'quart', 'gallon',
        'oz', 'lb',
        'mm', 'cm', 'm', 'km', 'hectare', 'ml', 'litre',
        'gm', 'kg',
        's', 'min', 'hr'
      ].map(sym => getSymbol(sym))   // filter out any non-units (user may have redefined some)
             .filter(val => val.type === 'num' && val.val && !Dim.isScalar(val.dim));

      function val2str(val, opts) {
        let descStr = "";
        if (opts?.describe && val.desc)
          descStr = ` (${val.desc})`;
        let unitsStr = "", invUnitsStr = "";
        if (val.val !== undefined) {
          let dim = val.dim;
          let uscu = !!val.uscu;
          val = val.val;
          // Find best units to express the value in
          let iterations = 0;
          while (!Dim.isScalar(dim)) {
            if (++iterations > 100)
              throw "Failed to reduce units";
            let unitDescs = [];
            for (const unit of candidateUnits) {
              const [exp, reduced] = Dim.reduce(dim, unit.dim);
              let newVal = val;
              let posExp = 0, negExp = 0;
              if (exp) {
                for (const measure in unit.dim) {
                  // It's more precice to avoid raising to negative powers.
                  // This avoids some .9999999999999999 scenarios.
                  if (!unit.dim[measure])
                    continue;
                  if (exp > 0) {
                    const divisor = Math.pow(unit.val, exp);
                    newVal = newVal / divisor;
                    posExp += 1;
                  } else if (exp < 0) {
                    const factor = Math.pow(unit.val, -exp);
                    newVal = newVal * factor;
                    negExp += 1;
                  }
                }
                unitDescs.push({unit, exp, posExp, negExp, newVal, reduced});
              }
            }
            unitDescs.sort((a,b) => {  // Note that we're sorting from best to worst
              function cmp(a,b) {
                // Units system should match
                // (unit.uscu === null is a hack for units like time that are universal)
                if (a.unit.uscu !== null && b.unit.uscu !== null
                    && !a.unit.uscu !== !b.unit.uscu) {
                  if (uscu === !a.unit.uscu)
                    return 1;
                  return -1;
                }

                // Negative exponents go first
                if (!!a.negExp !== !!b.negExp) {
                  if (!!a.negExp)
                    return -1;
                  return 1;
                }

                // Values greater than 1 beat values less than one
                if (a.newVal >= 1 && b.newVal < 1)
                  return -1;
                if (b.newVal >= 1 && a.newVal < 1)
                  return 1;

                // Smaller values beat larger
                return a.newVal - b.newVal;
              }
              // ensure comparitor is well-behaved
              let res = cmp(a,b), rev = cmp(b,a);
              if (res !== -rev)
                throw "bad comparitor";
              return res
            });
            console.log("======== " + parseStr + " ========"); // XXX
            console.log(JSON.stringify(unitDescs, null, 2)); // XXX
            if (unitDescs.length < 1)
              throw "system error: insufficient basis units";
            const unitDesc = unitDescs[0];
            let str = " ";
            let displayExp = unitDesc.exp;
            if (displayExp < 0) {
              displayExp = -displayExp;
              str += " /"
            }
            str += unitDesc.unit.sym;
            if (displayExp !== 1) {
              let expStr = String(displayExp);
              if (opts?.html)
                expStr = `<sup>${expStr}</sup>`;
              str += expStr;
            }
            if (unitDesc.exp < 0)
              invUnitsStr += str;
            else
              unitsStr += str;
            val = unitDesc.newVal;
            dim = unitDesc.reduced;
          }
        }
        if (opts?.saveMode) {
          // full precision value
          return String(val) + unitsStr + invUnitsStr;
        } else if (Math.abs(val) < 10000 * EPSILON) {
          return String(val) + unitsStr + invUnitsStr + descStr;
        } else {
          // Avoids display of nonsense like 2.5000...001 while
          // maintaining accuracy to "DIGITS_PRECISION" decimal digits.
          val = val.toFixed(DIGITS_PRECISION);
          while (val.endsWith("0"))
            val = val.substr(0, val.length-1);
          if (val.endsWith("."))
            val = val.substr(0, val.length-1);
          return val + unitsStr + invUnitsStr + descStr;
        }
      }

      function updateResult() {
        try {
          const ft = getField('ft', 0);
          const inch = getField('inch', 0);
          const num = getField('num', 0);
          const denom = getField('denom', 1);
          const times = getField('times', 1);
          const div = getField('div', 1);
          if (denom === 0 || div === 0) throw "Divide by zero";

          let totalInches = (ft*12 + inch + num/denom) * times / div;
          if (isNaN(totalInches)) throw "Bad input";
          if (!isFinite(totalInches)) throw "Divide by zero"

          showFeetInchesResult(totalInches*IN, { updateExpr: true });
        }
        catch (e) {
          showError(e);
        }
      }

      function showError(e, opts) {
        // always update the text, in case the error box is already showing
        let msg = e;
        if (e instanceof ChattyError)
          msg = e.message;
        document.getElementById('error').textContent = String(msg);
        if (!opts?.allErrors && e instanceof ChattyError)
          return;
        // we had an error so hide the results block and show the error block
        document.getElementById('results').style.display = 'none';
        document.getElementById('numberResults').style.display = 'none';
        document.getElementById('error').style.display = '';
      }

      //
      // Parser, for general calculation with expressions
      //

      let parseStr = "", initialParseStr = "";
      let parsePos = 0, parseFurthest = 0;
      const DIGITS = "0123456789";
      const ALPHA =
        "abcdefghijklmnopqrstuvwxyz" +
        "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
      const ALPHANUM = ALPHA + DIGITS;
      const NOSKIP = { noSkip: true };

      function peekc() {
        if (parsePos < parseStr.length)
          return parseStr.charAt(parsePos);
        return null;
      }

      function getc() {
        if (parsePos < parseStr.length) {
          let ch = parseStr.charAt(parsePos);
          parsePos += 1;
          if (parsePos > parseFurthest && parseStr === initialParseStr)
            parseFurthest = parsePos;
          return ch;
        }
        return null;
      }

      function take(match, opts) {
        const backtrack = parsePos;
        if (!opts?.noSkip)
          skipSpaces();
        if (parseStr.charAt(parsePos) === match) {
          parsePos += 1;
          if (parsePos > parseFurthest && parseStr === initialParseStr)
            parseFurthest = parsePos;
          return true;
        }
        parsePos = backtrack;
        return false;
      }

      function skipSpaces() {
        let foundSpace = false;
        let ch = peekc();
        while (ch === " " || ch === "\t") {
          getc();
          ch = peekc();
          foundSpace = true;
        }
        return foundSpace;
      }

      // Numbers of form:
      //    ddd
      //    ddd.
      //    ddd.dd
      //    .ddd

      function parseNum(opts) {
        const backtrack = parsePos;
        let nDigits = 0;
        if (!opts?.noSkip)
          skipSpaces();
        let ch = peekc();
        if (DIGITS.includes(ch) || ch === ".") {
          let val = 0, div = 1;
          while (DIGITS.includes(ch)) {
            val = val*10 + parseInt(ch);
            getc();
            ch = peekc();
            nDigits += 1;
          }
          if (!opts?.intOnly && take('.', NOSKIP)) {
            ch = peekc();
            while (DIGITS.includes(ch)) {
              val = val*10 + parseInt(ch);
              div *= 10;
              getc();
              ch = peekc();
              nDigits += 1;
            }
          }
          const backtrack2 = parsePos;
          if (!opts?.intOnly && take('e', NOSKIP)) {
            take('+', NOSKIP);
            take('-', NOSKIP);
            if (DIGITS.includes(peekc())) {
              // let JavaScript parse the number
              while (DIGITS.includes(peekc()))
                getc();
              let str = parseStr.substring(backtrack, parsePos);
              let val = Number.parseFloat(str);
              if (isNaN(val)) {
                parsePos = backtrack;
                throw `Bad number: ${str}`;
              }
              return val;
            }
          }
          parsePos = backtrack2;
          if (nDigits > 0)
            return val/div; 
          parsePos = backtrack;    
        }
        return null;
      }

      // Parse a number or a number followed by fraction or a fraction:
      //    n
      //    n n/n
      //    n/n

      function parseNumFrac(opts) {
        let val = parseNum(opts);
        if (val === null)
          return null;
        const backtrack = parsePos;
        if (take('/', NOSKIP)) {
          let denom = parseNum({ noSkip: true, intOnly: true });
          if (denom === null) {
            parsePos = backtrack;
            return val;
          }
          const q = val/denom;
          if (!isFinite(q)) throw "Divide by zero";
          return q;
        }
        let num = parseNum({ intOnly: true });
        if (num === null)
          return val;
        if (take('/'), NOSKIP) {
          let denom = parseNum({ noSkip: true, intOnly: true });
          if (denom !== null) {
            const q = num/denom;
            if (!isFinite(q)) throw "Divide by zero";
            return val + q;
          }
        }
        parsePos = backtrack;
        return val;
      }

      // Parse a value, which is either a plain number (n) or a sequesnce of
      // number-fractions (nf) each followed by a unit:
      //    n
      //    nf unit
      //    nf unit [ nf [ '/'? unit ['^' n]? ]+ ]*
          
      function parseValue(opts) {
        const backtrack1 = parsePos;
        let num = 0, dim;
        let lastUnitVal = Number.POSITIVE_INFINITY;
        let uscu = false;   // consider it metric unless we encounter any non-metric unit

        // The idea of lastUnitVal is that units should get progressively smaller.
        // Otherwise, someone could enter 2'3' when they meant 2'3"

        while (true) {  // additive chunks [nf unit unit unit]*
          let chunkVal = parseNumFrac(opts);
          if (chunkVal === null)
            break;
          let chunkDim = {};
          let gotUnit = false;
          if (take("'")) {
            if (FT >= lastUnitVal) throw "Implausible units";
            lastUnitVal = FT;
            chunkDim.L = 1;
            chunkVal *= FT;
            uscu = true;
            gotUnit = true;
          } else if (take('"')) {
            if (IN >= lastUnitVal) throw "Implausible units";
            lastUnitVal = 1;
            chunkDim.L = 1;
            chunkVal *= IN;
            uscu = true;
            gotUnit = true;
          } else {
            // system and user-defined units
            while (true) {
              const backtrack2 = parsePos;
              let hasSlash = take('/');
              let word = parseWord({ ...opts, noSkip: hasSlash });
              if (!word) {
                parsePos = backtrack2;
                break;
              }
              const sym = getSymbol(word);
              if (!sym)
                throw new ChattyError(`Unknown unit: "${word}"`);
              if (Dim.isScalar(sym.dim) || !sym.val)
                throw new ChattyError(`Not a unit: "${word}"`);
              let symVal = sym.val;
              if (symVal.val >= lastUnitVal) throw "Implausible units";
              lastUnitVal = sym.val;
              let saveChunkDim = chunkDim;
              if (hasSlash)
                chunkDim = Dim.sub(chunkDim, sym.dim);
              else
                chunkDim = Dim.add(chunkDim, sym.dim);
              if (hasSlash)
                chunkVal /= symVal;
              else
                chunkVal *= symVal;
              if (sym.uscu)
                uscu = true;
              gotUnit = true;
            }
          }
          if (!gotUnit) {
            dim = undefined;
            parsePos = backtrack1;
            break;
          }
          if (!dim)
            dim = chunkDim;
          else if (!Dim.equal(dim, chunkDim))
            throw new ChattyError("Implausible units");
          num += chunkVal;
        }
        if (dim)
          return { type: 'num', dim, val: num, uscu };
        parsePos = backtrack1;
        num = parseNum(opts);
        if (num !== null)
          return  {type: 'num', dim: {}, val: num };
        return null;
      }

      // Parse a word

      function parseWord(opts) {
        const backtrack = parsePos;
        if (!opts?.noSkip)
          skipSpaces();
        if (ALPHA.includes(peekc())) {
          let word = getc();
          while (ALPHANUM.includes(peekc()))
            word += getc();
          return word;
        }
        parsePos = backtrack;
        return null;
      }

      // Parse a term, which is either a unary expression, a
      // parenthesized expression, a function call, a value or a word (variable)
      //    '+' term
      //    '-' term
      //    '/' term     -- reciprocal
      //    '(' expr ')'
      //    term [ '(' [ expr [ ',' expr ]* ]? ')' ]+
      //    value
      //    word

      function parseTerm(opts) {
        const backtrack = parsePos;

        // Deal with unary first
        if (take('+')) {
          let val = parseTerm(opts);
          if (val !== null)
            return val;
          parsePos = backtrack;
          return null;
        }
        if (take('-')) {
          let val = parseTerm(opts);
          if (val !== null) {
            if (val.type === 'fn') throw new ChattyError("Can't negate functions");
            if (val.type === 'parse')
              return { type: 'parse', op: 'neg', expr: val };
            return { type: val.type, dim: val.dim, val: -val.val, uscu: val.uscu };
          }
          parsePos = backtrack;
          return null;
        }
        if (take('/')) {
          let val = parseTerm(opts);
          if (val !== null) {
            if (val.type === 'fn') throw new ChattyError("can't divide functions");
            if (val.type === 'parse')
              return { type: 'parse', op: 'recip', expr: val };
            const q = 1/val.val;
            if (!isFinite(q)) throw "Divide by zero";
            return { type: val.type, dim: Dim.mul(val.dim, -1), val: q, uscu: val.uscu };
          }
          parsePos = backtrack;
          return null;
        }

        // Now deal with exprs that might or might not be followed by function invocation
        let val = null;
        if (take('(')) {
          let val1 = parseExpr(opts);
          if (val1 && take(')')) {
            val = val1;
          }
        } else {
          const word = parseWord(opts);
          if (word !== null) {
            let val1 = getSymbol(word);
            skipSpaces();
            // As a special case, a function of no arguments can be used as a constant
            if (peekc() !== '('
                && val1 instanceof Object && val1.type === 'fn' && val1.params.length === 0)
              val = invokeFunction(val1, []);
            else if (!(val1 instanceof Object && val1.type))
              throw new ChattyError(`Unknown variable: "${word}"`);
            else
              val = val1;
          } else {
            if (opts?.noUnits) {
              val = parseNum(opts);
              if (val !== null)
                val = { type: 'num', dim: {}, val: val };
            } else {
              val = parseValue(opts);
            }
          }
        }
        if (val === null) {
          parsePos = backtrack;
          return null;
        }

        // This loops because a function can return a function
        while (take('(')) {
          const params = [];
          let arg = parseExpr(opts);
          while (arg !== null) {
            params.push(arg);
            if (!take(','))
              break;
            arg = parseExpr(opts);
          }
          if (!take(')')) {
            parsePos = backtrack;
            return null;
          }
          let paramsParse = false;
          for (const p of params)
            if (p.type === 'parse')
               paramsParse = true;
          if (paramsParse || val.type === 'parse')
            val = { type: 'parse', op: 'call', expr: val, params: params };
          else
            val = invokeFunction(val, params);
        }
        return val;
      }

      // Parse an exponentiation expression (right-associative)
      //    term '^' exponentiation
      //    term

      function parseExponentiation(opts) {
        let val = parseTerm(opts);
        if (val === null)
          return null;
        const backtrack = parsePos;
        if (take('^')) {
          let exp = parseExponentiation({ ...opts, noUnits: true });
          if (!exp) {
            parsePos = backtrack;
            return val;
          }
          if (val.type === 'fn' || exp.type === 'fn')
            throw "Cannot exponentiate functions";
          if (val.type === 'parse' || exp.type === 'parse')
            return { type: 'parse', op: 'exp', expr1: val, expr2: exp };
          if (!Dim.isScalar(exp.dim))
            throw "Must exponentiate with a scalar";
          if (!Dim.isScalar(val.dim) && exp.val !== Math.trunc(exp.val))
            throw "Cannot exponentiate non-scalars by non-integers";
          return { type: 'num', dim: Dim.mul(val.dim, exp.val),
            val: Math.pow(val.val, exp.val), uscu: val.uscu };
        }
        return val;
      }

      // Parse a multiplicitive expression:
      //    exponentiation [ '*' exponentiation ]*
      //    exponentiation [ '/' exponentiation ]*

      function parseMulExpr(opts) {
        const backtrack = parsePos;
        let val = parseExponentiation(opts);
        if (val === null)
          return null;
        while (true) {
          if (take('*') || take('\u00D7')) {  // '*' or times sign
            let val2 = parseExponentiation(opts);
            if (val2 === null) {
              parsePos = backtrack;
              return null;
            }
            if (val.type === 'fn' || val2.type === 'fn')
              throw "Can't multiply functions";
            if (val.type === 'parse' || val2.type === 'parse')
              val = { type: 'parse', op: '*', expr1: val, expr2: val2 };
            else if (val.type === 'num' && val2.type === 'num')
              val = { type: 'num', dim: Dim.add(val.dim, val2.dim), val: val.val * val2.val,
                uscu: val.uscu || val2.uscu };
            else
              throw "Unknown value type";
          } else if (take('/') || take('\u00F7')) { // '/' or divide sign
            let val2 = parseExponentiation(opts);
            if (val2 === null) {
              parsePos = backtrack;
              return null;
            }
            if (val.type === 'fn' || val2.type === 'fn')
              throw "Can't divide functions";
            if (val.type === 'parse' || val2.type === 'parse') {
              val = { type: 'parse', op: '/', expr1: val, expr2: val2 };
            } else if (val.type === 'num' && val2.type === 'num') {
              const q = val.val / val2.val;
              if (!isFinite(q)) throw "Divide by zero";
              val = { type: 'num', dim: Dim.sub(val.dim, val2.dim), val: q,
                uscu: val.uscu || val2.uscu };
            } else {
              throw "Unknown value type";
            }
          } else {
            break;
          }
        }
        return val;
      }

      // Parse an (additive) expression:
      //    mulexpr [ '+' mulexpr ]*
      //    mulexpr [ '-' mulexpr ]*

      function parseExpr(opts) {
        const backtrack = parsePos;
        let val = parseMulExpr(opts);
        if (val === null)
          return null;
        while (true) {
          if (take('+')) {
            let val2 = parseMulExpr(opts);
            if (val2 === null) {
              parsePos = backtrack;
              return null;
            }
            if (val.type === 'fn' || val2.type === 'fn')
              throw new ChattyError("Can't add functions");
            if (val.type === 'parse' || val2.type === 'parse') {
              val = { type: 'parse', op: '+', expr1: val, expr2: val2 };
            } else if (val2.val === 0) {
              // special case for adding 0; keep first val
            } else if (val.val === 0) {
              val = val2;  // special case for adding 0; take second val
            } else if (val.type === 'num' && val2.type === 'num') {
              if (Dim.equal(val.dim, val2.dim)) 
                val = { type: 'num', dim: val.dim, val: val.val + val2.val,
                  uscu: val.uscu || val2.uscu };
              else
                throw new ChattyError("Cannot add different unit types")
            } else {
              throw "Unknown value type";
            }
          } else if (take('-')) {
            let val2 = parseMulExpr(opts);
            if (val2 === null) {
              parsePos = backtrack;
              return null;
            }
            if (val.type === 'fn' || val2.type === 'fn')
              throw "Can't subtract functions";
            if (val.type === 'parse' || val2.type === 'parse') {
              val = { type: 'parse', op: '-', expr1: val, expr2: val2 };
            } else if (val2.val === 0) {
              // special case for subtracting 0; take first val
            } else if (val.type === 'num' && val2.type === 'num') {
              if (Dim.equal(val.dim, val2.dim))
                val = { type: 'num', dim: val.dim, val: val.val - val2.val,
                  uscu: val.uscu && val2.uscu };
              else
                throw new ChattyError("Cannot subtract different unit types")
            }
            else {
              throw "Unknown value type";
            }
          } else {
            break;
          }
        }
        return val;
      }

      // Parse a statement:
      //    expr
      //    word '=' expr
      //    word '(' [ word [ ',' word ]* ]? ')' '=' expr

      function parseStatement(opts) {
        const backtrack = parsePos;
        let word = parseWord(opts);
        if (word !== null) {
          if (take('=')) {
            let val = parseExpr(opts);
            if (val) {
              return { ...val, sym: word, defined: true };
            }
          }
          if (take('(')) {
            let params = [];
            let param = parseWord(opts);
            while (param !== null) {
              params.push(param);
              if (!take(','))
                break;
              param = parseWord(opts);
            }
            if (take(')') && take('=')) {
              // make sure the parameters all have different names
              const paramNames = {};
              for (const p of params) {
                if (paramNames[p]) throw `duplicate parameter ${p} in function ${word}`;
                paramNames[p] = true;
              }
              const saveEnv = environment;
              try {
                environment = {};
                for (const p of params)
                  environment[p] = { type: 'parse', sym: p, defined: true };
                skipSpaces();
                const exprStart = parsePos;
                let expr = parseExpr(opts);
                environment = saveEnv;
                if (expr !== null)
                  return { type: 'fn', expr: expr, sym: word, defined: true,
                           params: params, body: parseStr.substr(exprStart) };
               }
               catch (e) {
                 environment = saveEnv;
                 throw e;
               }
             }
           }
           parsePos = backtrack;
        }
        return parseExpr();
      }

      //
      // Set up the initial parser state and parse a statement,
      // making sure all the input is consumed.
      //
      function parseInputStatement(stmt, env, opts) {
        parseStr = initialParseStr = stmt;
        parsePos = 0;
        parseFurthest = 0;
        environment = env || {};
        let val = parseStatement(opts);
        skipSpaces();
        if (val === null || peekc()) {
          let rest = parseStr.substr(parseFurthest);
          if (rest.length > 0)
            throw new ChattyError(`Cannot parse beyond "${rest}"`);
          else if (parseStr.trim() !== "")
            throw new ChattyError(`Incomplete input`);
        }
        return val;
      }

      function updateParse(userHitEnter) {
        clearFields();
        try {
          let val = parseInputStatement(document.getElementById('expr').value);
          if (val !== null) {
            if (userHitEnter && val.defined) {
              const sym = val.sym;
              const symVal = getSymbol(sym);
              if (symVal?.reserved) {
                let name = `"${sym}"`;
                if (symVal.desc && symVal.desc !== sym)
                  name = `${name} (${symVal.desc})`;
                throw `Cannot redefine reserved symbol ${name}`;
              }
              showAssignResult(val);
              delete val.defined;       // removes the flag that forces the definition
              delete val.desc;          // removes description
              delete userSymbols[sym];  // put the redefined symbol at the end by deleting first
              userSymbols[sym] = val;
              showUserSymbols();
            } else if (val.type === 'num' && val.uscu && Dim.equal(val.dim, { L: 1 })) {
              showFeetInchesResult(val.val);
            } else if (val.type === 'num') {
              showResult(val);
            } else if (val.type === 'fn' && !val.defined) {
              showAssignResult(val);
            }
            return;
          } else {
            let rest = parseStr.substr(parseFurthest);
            if (rest.length > 0)
              throw new ChattyError(`Cannot parse beyond "${rest}"`);
            else if (parseStr.trim() !== "")
              throw new ChattyError(`Incomplete input`);
          }
        }
        catch (e) {
          showError(e, { allErrors: userHitEnter });
        }

        // Gray out the result since we can't parse correctly right now
        document.getElementById('results').style.color = '#aaaaaa';  
        document.getElementById('numberResults').style.color = '#aaaaaa';
      }

      function clearFields() {
        for (const field of ['ft', 'inch', 'num', 'times', 'div'])
          document.getElementById(field).value = "";
      }

      function showResult(val) {
        document.getElementById('results').style.display = 'none';
        document.getElementById('numberResults').style.display = '';
        document.getElementById('error').style.display = 'none';
        document.getElementById('numberResults').style.color = '';

        document.getElementById('numberResultsDetail').innerHTML = val2str(val, { html: true, describe: true });
      }

      function escapeHTML(str) {
        return str
          .replace(/&/g, "&amp;")
          .replace(/</g, "&lt;")
          .replace(/>/g, "&gt;")
          .replace(/"/g, "&quot;")
          .replace(/'/g, "&#039;");
      }

      function showUserSymbols() {
        document.getElementById('symdefs');
        let str = "";
        // It seems like sorting is a good idea, but
        // JavaScript keeps entries in definition order and
        // it's nice to list them in the reverse order of definition
        let keys = Object.keys(userSymbols).reverse();
        for (const sym of keys) {
          let symStr = symString(userSymbols[sym]);
          if (symStr)
            str += `<p class="user-def"><span class="delete-button" onclick="deleteDef('${sym}')"></span>
              ${escapeHTML(symStr)}</p>`;
        }
        document.getElementById('symdefs').innerHTML = str;
      }

      function deleteDef(sym) {
        delete userSymbols[sym];
        showUserSymbols()
      }

      function symString(val, opts) {
        if (Dim.equal(val.dim, { um: 1 }) && !opts?.saveMode) {
          let [ftStr, inStr, delta] = unitsToUSStringReps(val.val);
          return `${val.sym} = ${ftStr}${delta}`;
        }
        if (val.type === 'num') {
          return `${val.sym} = ${val2str(val, opts)}`;
        }
        if (val.type === 'fn') {
          return `${val.sym}(${val.params.join(", ")}) = ${val.body}`;
        }
        return undefined;
      }

      function showAssignResult(val) {
        let str = symString(val);
        if (!str)
          return;
        document.getElementById('results').style.display = 'none';
        document.getElementById('numberResults').style.display = '';
        document.getElementById('error').style.display = 'none';
        document.getElementById('numberResults').style.color = '';
        document.getElementById('numberResultsDetail').textContent = str;
      }

      function showFeetInchesResult(totalUnits, opts) {

        document.getElementById('results').style.display = '';
        document.getElementById('numberResults').style.display = 'none';
        document.getElementById('error').style.display = 'none';
        document.getElementById('results').style.color = '';

        document.getElementById('resultIn').textContent = val2str(totalUnits/IN);
        document.getElementById('resultFt').textContent = val2str(totalUnits/FT);

        let [ftStr, inStr, delta] = unitsToUSStringReps(totalUnits);
        document.getElementById('resultFtDetail').textContent = ftStr + delta;
        if (opts?.updateExpr)
          document.getElementById('expr').value = ftStr + delta;

        document.getElementById('resultInDetail').textContent = inStr + delta;

        // show metric for good measure
        document.getElementById('resultMeters').textContent =
          val2str(totalUnits/M);
        document.getElementById('resultMetersMetricFeet').textContent =
          val2str((totalUnits/M)/(2.54/2.50));
      }

      function unitsToUSStringReps(totalUnits) {
        let totalInches = totalUnits/IN;
        let minus = "";
        if (totalInches < 0) {
          totalInches = -totalInches;
          minus = "-";
        }

        // Recover feet and inches from from result
        // (round to nearest 1/denom)
        let denom = 32;
        let inches =  Math.trunc(totalInches*denom + 0.5)/denom;
        let ft = Math.trunc(inches/12);
        inches = inches - ft*12;
        let frac = inches - Math.trunc(inches);
        inches = Math.trunc(inches);
        let num = Math.trunc(frac*denom);
        while (denom > 2 && num%2 === 0) {  // reduce fraction
          denom = denom/2;
          num = num/2;
        }

        // format that string
        let ftStr = minus, sp = "";
        if (ft !== 0 || (inches === 0 && num === 0)) {
          ftStr += ft + "'";
          sp = " ";
        }
        if (inches !== 0) {
          ftStr += sp + inches;
          sp = " ";
        }
        if (num !== 0)
          ftStr += `${sp}${num}/${denom}`;
        if (inches !== 0 || num !== 0)
           ftStr += '"';
        let delta = totalInches - (ft*12 + inches + num/denom);
        if (Math.abs(delta) < EPSILON) {
          delta = "";
        } else {
          if (delta < 0)
            delta = ` - ${val2str(-delta)}"`;
          else
            delta = ` + ${val2str(delta)}"`;
        }
 
        // format inches
        let inStr = minus;
        sp = "";
        inches = ft*12 + inches;
        if (inches !== 0 || num === 0) {
          inStr += inches;
          sp = " ";
        }
        if (num !== 0)
          inStr += `${sp}${num}/${denom}`;
        inStr += '"';
        return [ftStr, inStr, delta];
      }

      function showHelp(id) {
        // hide all help
        let elts = document.querySelectorAll('div.help');
        for (let e of elts)
          e.style.display = ''; // back to inherited 'none'
        let helpElement = document.getElementById(id);
        if (helpElement) {
          helpElement.style.display = "block"; // inherits 'none' from "help" class
          for (let child of helpElement.children)
            if (child.tagName === 'DIV')
              child.scroll(0, 0);
        }
      }

      const GUID = "ad1f9c32-ed69-457d-89a0-f966c81424bd";
      const LOCAL_STORAGE_KEY = "FeetInchCalculator-" + GUID;
      const MAJOR = 1, MINOR = 0, PATCH = 0;

      function loadUserSymbols() {
        const localStorage = window.localStorage;
        if (!localStorage)
          return false;
        try {
          let json = localStorage.getItem(LOCAL_STORAGE_KEY);
          if (!json)
            return false;
          let wad = JSON.parse(json);
          if (!wad || !wad.major || wad.major > MAJOR)
            return false;
          if (!wad.defs)
            return false;
          for (const def of wad.defs) {
            try {
              let val = parseInputStatement(def);
              skipSpaces();
              if (val !== null && !peekc()) { // nothing left over at the end
                let sym = val.sym;
                if (systemSymbols[sym]?.reserved)
                  next;
                delete val.defined;
                userSymbols[sym] = val;
              }
            }
            catch (e) {
            }
          }
          showUserSymbols();
          return true;
        }
        catch (e) {
        }
        return false;    
      }

      function saveUserSymbols() {
        const localStorage = window.localStorage;
        if (!localStorage)
          return false;
        const wad = {
          major: MAJOR, minor: MINOR, patch: PATCH, defs: []
        };
        // We rely on the fact that objects are enumerated in the order
        // items were added. Otherwise, function definitions might fail
        // due to their variable references being unsatisfied.
        for (const sym in userSymbols) {
          let symStr = symString(userSymbols[sym], { saveMode: true });
          if (symStr) {
            wad.defs.push(symStr);
            // console.log(`Saving: ${symStr}`);
          }
        }
        let json = JSON.stringify(wad);
        try {
          localStorage.setItem(LOCAL_STORAGE_KEY, json);
          return true;
        }
        catch (e) {
        }
        return false;
      }

      function addExampleStuffs() {
        for (const help of document.querySelectorAll("div.help")) {
          help.addEventListener("click", function(event) {
            let styles = window.getComputedStyle(event.target);
            let action = styles.getPropertyValue("--click-action");
            if (action.trim() === "stuff-text") {
              let text = event.target.textContent.trim();
              document.getElementById('expr').value = text.trim();
              updateParse(true);
            }
          });
        }
      }

      function addBuiltinSymbolsHelp() {
        let html = "";
        for (const sym in systemSymbols) {
          const val = systemSymbols[sym];
          if (val.type !== 'num')
            continue;
          let desc = val.desc ?? sym;
          if (val.reserved)
            desc += " <i>(reserved)</i>";
          html += `<tr><td>${sym}<td>/${sym}<td>${desc}`;
        }
        document.getElementById('builtin-symbols').innerHTML = html;
      }

      window.addEventListener('load', function onLoad(evt) {
        loadUserSymbols();
        updateResult();
        addExampleStuffs();
        addBuiltinSymbolsHelp()
      });

      window.addEventListener("beforeunload", function(evt) {
        saveUserSymbols();
      });

      document.addEventListener("keydown", function(evt) {
        evt = evt || window.event;
        if (evt.key === "Escape" || evt.key === "Esc" || evt.keyCode === 27)
          showHelp();
      });
   </script>
  </body>
</html>