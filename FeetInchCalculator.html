<html>
  <title>Feet & Inch Calculator</title>
  <body onload="updateResult()" 
      style="margin: 1em 2em; font-family: system-ui; background-color: white; color: #212121">
    <style>
      .help {
        padding: 0px 20px;
        background-color: #eeeeee;
        position: fixed;
        display: none;
        width: 60%;
        height: 80%;
        top: 10%;
        left: 30%;
        border: 2px solid black;
      }
      .help .closebtn {
        margin-left: 15px;
        color: #888888;
        font-weight: bold;
        float: right;
        font-size: 40px;
        line-height: 40px;
        cursor: pointer;
        transition: 0.3s;
      }
      .help .closebtn:hover {
        color: black;
      }
      .help td {
        padding: 0px 10px;
        vertical-align: top;
      }
      .help th {
        padding: 0px 10px;
        text-align: left;
      }
      .help > div {
        overflow-y: scroll;
        height: 100%;
      }
      .help code {
        font-size: 140%;
        font-weight: bold;
      } 
      .help code.abstract {
        font-style: oblique;
      } 
      span.button {
        cursor: pointer;
        background: #4444ff;
        border-radius: 4px;
        color: white;
        transition: 0.3s;
      }
      .button:hover {
        background: #0000cc;
      }
      #symdefs p {
        margin: 0px;
        font-size: 120%;
      }
    </style>
    <script type="text/javascript">
      "use strict";

      // A curious thing worth noting: It turns out that fractions of the form
      // "n / power-of-2" are precicely the values that can be represented exactly
      // in floating point arithmetic and also the conventional way of expressing
      // fractional inches. So doing all arithmetic in units of inches means that
      // calculations can be exact when exact results are possible.

      //
      // Simple interface for common operations
      //

      function getField(name, def) {
        document.getElementById(name).style.color = '';
        let val = document.getElementById(name).value.trim();
        if (val === "") return def;
        val = parseFloat(val);
        if (isNaN(val) || (val === 0 && def !== 0))
          document.getElementById(name).style.color = 'red';
        return val;
      }

      const digits = 10, epsilon = Math.pow(10, -digits);

      function num2str(val) {
        // Avoids display of nonsense like 2.5000...001 while
        // maintaining accuracy to "digits" decimal digits.
        val = val.toFixed(digits);
        while (val.endsWith("0"))
          val = val.substr(0, val.length-1);
        if (val.endsWith("."))
          val = val.substr(0, val.length-1);
        return val;
      }

      function updateResult() {
        try {
          let ft = getField('ft', 0);
          let inch = getField('inch', 0);
          let num = getField('num', 0);
          let denom = getField('denom', 1);
          let times = getField('times', 1);
          let div = getField('div', 1);

          if (denom === 0 || div === 0)
            throw "Divide by zero";

          let totalInches = (ft*12 + inch + num/denom) * times / div;
          if (isNaN(totalInches))
            throw "Bad input";

          showResult(totalInches, true);
        }
        catch (e) {
          showError(e);
        }
      }

      function showError(e) {
        if (e instanceof SilentError)
          return;

        // we had an error so hide the results block and show the error block
        document.getElementById('results').style.display = 'none';
        document.getElementById('numberResults').style.display = 'none';
        document.getElementById('error').style.display = '';
        document.getElementById('error').textContent = String(e);
      }

      //
      // Parser, for general calculation with expressions
      //

      let parsestr = "", parsepos = 0;
      const DIGITS = "0123456789";
      const ALPHA =
        "abcdefghijklmnopqrstuvwxyz" +
        "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
      const ALPHANUM = ALPHA + DIGITS;

      function peekc() {
        if (parsepos < parsestr.length)
          return parsestr.charAt(parsepos);
        return null;
      }

      function getc() {
        if (parsepos < parsestr.length) {
          let ch = parsestr.charAt(parsepos);
          parsepos += 1;
          return ch;
        }
        return null;
      }

      function take(match, noskip) {
        if (!noskip)
          skipSpaces();
        if (peekc() === match) { // make the single character case faster
          parsepos += 1;
          return true;
        }
        if (parsestr.substr(parsepos, match.length).toLowerCase() !== match)
          return false;
        parsepos += match.length;
        return true;
      }

      function skipSpaces() {
        let foundSpace = false;
        let ch = peekc();
        while (ch === " " || ch === "\t") {
          getc();
          ch = peekc();
          foundSpace = true;
        }
        return foundSpace;
      }

      class SilentError extends Error {
        constructor(msg) {
          super();
          this.msg = msg;
        }
      }

      // Numbers of form:
      //    ddd
      //    ddd.dd
      //    .ddd

      function parseNum() {
        const backtrack = parsepos;
        let nDigits = 0
        skipSpaces();
        let ch = peekc();
        if (DIGITS.includes(ch) || ch === ".") {
          let val = 0, div = 1;
          while (DIGITS.includes(ch)) {
            val = val*10 + parseInt(ch);
            getc();
            ch = peekc();
            nDigits += 1;
          }
          if (take('.', true)) {
            ch = peekc();
            while (DIGITS.includes(ch)) {
              val = val*10 + parseInt(ch);
              div *= 10;
              getc();
              ch = peekc();
              nDigits += 1;
            }
          }
          if (nDigits > 0)
            return val/div; 
          parsepos = backtrack;    
        }
        return null;
      }

      // Parse a number or a number followed by fraction or a fraction:
      //    n
      //    n n/n
      //    n/n

      function parseNumFrac() {
        let val = parseNum();
        if (val === null)
          return null;
        const backtrack = parsepos;
        if (take('/')) {
          let denom = parseNum();
          if (denom === null) {
            parsepos = backtrack;
            return val;
          }
          if (denom === 0)
            throw "Divide by zero";
          return val/denom;
        }
        let num = parseNum();
        if (num === null)
          return val;
        if (take('/')) {
          let denom = parseNum();
          if (denom !== null) {
            if (denom === 0) new MessageError("Divide by zero");
            return val + num/denom;
          }
        }
        parsepos = backtrack;
        return val;
      }

      // Parse a value, which is either a plain number (n) or a sequesnce of
      // number-fractions (nf) each followed by a unit:
      //    n
      //    nf unit
      //    nf unit nf unit ...
          
      function parseVal() {
        let backtrack1 = parsepos;
        let inches = 0, haveLength = false, lastUnit = Number.POSITIVE_INFINITY;

        // The idea of ;astUnit is that units should get progressively smaller.
        // Otherwise, someone could enter 2'3' when they meant 2'3"

        while (true) {
          const backtrack2 = parsepos;
          let val = parseNumFrac();
          if (val === null)
            break;
          if (take("'")) {
            if (12 >= lastUnit)
              throw "Implausible units";
            lastUnit = 12;
            inches += val*12;
          } else if (take('"')) {
            if (1 >= lastUnit)
              throw "Implausible units";
            lastUnit = 1;
            inches += val;
          } else {
            // system and user-defined units
            let word = parseWord(), ok = false;
            if (word) {
              const symVal = getSymbol(word);
              if (symVal && symVal.type === 'in') {
                if (symVal.val >= lastUnit)
                  throw "Implausible units";
                lastUnit = symVal.val;
                inches += val * symVal.val;
                ok = true;
              }
            }
            if (!ok) {
              parsepos = backtrack2;
              break;
            }
          }
          haveLength = true;
        }
        if (haveLength)
          return { type: 'in', val: inches };

        // if there are no units, we can only use the plain number
        parsepos = backtrack1;
        let val = parseNum();
        if (val !== null)
          return { type: 'num', val: val };
        return null;
      }

      // Parse a word

      function parseWord() {
        const backtrack = parsepos;
        skipSpaces();
        if (ALPHA.includes(peekc())) {
           let word = getc();
           while (ALPHANUM.includes(peekc()))
             word += getc();
           return word;
        }
        parsepos = backtrack;
        return null;
      }

      const symbols = {
        pi: Math.PI,
        in: { type: 'in', val: 1 },
        ft: { type: 'in', val: 12 },
        cm: { type: 'in', val: 1/2.54 },
        m:  { type: 'in', val: 1/0.0254 },
        // Let the user define these if they want to
        //   yd: { type: 'in', val: 36 },  
        //   mi: { type: 'in', val: 5280*12 },
        //   km: { type: 'in', val: 1000/0.0254 },
        hyp: function(...params) {
          // General n-dimensional hypotenuse
          if (params.length < 1)
            return { type: 'num', val: 0 };
          let val = params.pop();
          let type = val.type;
          let accum = 0;
          while (true) {
            if (val.val !== 0) {
              if (val.type !== type) {
                if (accum !== 0)
                  throw this.sym + "(): parameter types incompatible";
                type = val.type;
              }
              accum += val.val * val.val;
            }
            val = params.pop();
            if (!val)
              break;
          }
          return { type: type, val: Math.sqrt(accum) };
        },
        mean: function(...params) {
          if (params.length < 1)
            throw this.sym + "(): no parameters";
          let val = params.pop();
          let type = val.type;
          let accum = 0, n = 0;
          while (true) {
            if (val.val === 0) {
              n += 1;
            } else {
              if (val.type !== type) {
                if (accum !== 0)
                  throw this.sym + "(): parameter types incompatible";
                type = val.type;
              }
              accum += val.val;
              n += 1;
            }
            val = params.pop();
            if (!val)
              break;
          }
          return { type: type, val: accum/n };
        }
      };

      const userSymbols = {}; 
      let environment = {};

      function getSymbol(name) {
        let val = environment[name];
        if (val === undefined)
          val = userSymbols[name];
        if (val === undefined)
          val = symbols[name];
        if (typeof val === 'number')
          val = { type: 'num', val: val };
        if (val instanceof Function)
          val = { type: 'fn', sym: name, params:["..."], native: val, body: `#builtin-${name}#` };
        return val;
      }   

      // Parse a term, which is either a parenthesized expression
      // or a + or - sign followed by a term:
      //    ( expr )
      //    + term
      //    - term
      //    fn ( expr, expr, ... )
      //    const

      function parseTerm() {
        const backtrack = parsepos;
        if (take('(')) {
          let val = parseExpr();
          if (val !== null && take(')')) {
            return val;
          }
          parsepos = backtrack;
          return null;
        }
        if (take('+')) {
          let val = parseTerm();
          if (val !== null)
            return val;
          parsepos = backtrack;
          return null;
        }
        if (take('-')) {
          let val = parseTerm();
          if (val !== null) {
            if (val.type === 'fn')
              throw "Can't negate functions";
            if (val.type === 'parse')
              return { type: 'parse', op: 'neg', expr: val };
            return { type: val.type, val: -val.val };
          }
          parsepos = backtrack;
          return null;
        }
        let word = parseWord();
        if (word !== null) {
          const symVal = getSymbol(word);
          if (symVal && take('(')) {
            let params = [];
            let val = parseExpr();
            while (val !== null) {
              params.push(val);
              if (!take(','))
                break;
              val = parseExpr();
            }
            if (take(')')) {
              let paramsParse = false;
              for (const p of params)
                if (p.type === 'parse')
                  paramsParse = true;
              if (paramsParse || symVal.type === 'parse')
                return { type: 'parse', name: word, params: params };
              if (symVal.type === 'fn') {
                if (symVal.native) {
                  val = symVal.native(...params);
                  if (val !== null)
                    return val;
                }
                if (params.length != symVal.params.length)
                  throw `incorrect number of params for ${word}(${symVal.params.join(',')})`;
                const saveEnv = environment, saveParsestr = parsestr, saveParsepos = parsepos;
                try {
                  environment = {};
                  parsestr = symVal.body;
                  parsepos = 0;
                  for (const i in params)
                    environment[symVal.params[i]] = params[i];
                  let val = parseExpr();
                  skipSpaces();
                  if (peekc())
                    throw "Invalid function";
                  environment = saveEnv;
                  parsestr = saveParsestr;
                  parsepos = saveParsepos
                  return val;
                }
                catch (e) {
                  environment = saveEnv;
                  parsestr = saveParsestr;
                  parsepos = saveParsepos;
                  throw e;
                }
              }
            }
            parsepos = backtrack;
            return null;
          }
          let val = symVal;
          if (val instanceof Object && val.type)
            return val;
          parsepos = backtrack;
          return null;
        }
        return parseVal();
      }

      // Parse a multiplicitive expression:
      //    primitive * primitive
      //    primitive / primitive

      function parseMulExpr() {
        const backtrack = parsepos;
        let val = parseTerm();
        if (val === null)
          return null;
        while (true) {
          if (take("*")) {
            let val2 = parseTerm();
            if (val2 === null) {
              parsepos = backtrack;
              return null;
            }
            if (val.type === 'fn' || val2.type === 'fn')
              throw "Can't multiply functions";
            if (val.type === 'parse' || val2.type === 'parse')
              return { type: 'parse', op: '*', expr1: val, expr2: val2 };
            if (val.type === 'num' && val2.type === 'num')
              val = { type: 'num', val: val.val * val2.val };
            else if (!(val.type === 'in' && val2.type === 'in'))
              val =  { type: 'in', val: val.val * val2.val };
            else
              throw "Cannot multiply lengths";
          } else if (take("/")) {
            let val2 = parseTerm();
            if (val2 === null) {
              parsepos = backtrack;
              return null;
            }
            if (val.type === 'fn' || val2.type === 'fn')
              throw "Can't divide functions";
            if (val.type === 'parse' || val2.type === 'parse')
              return { type: 'parse', op: '/', expr1: val, expr2: val2 };
            if (val2.val === 0)
              throw "Divide by zero";
            if (val.type === 'num' && val2.type === 'num')
              val =  { type: 'num', val: val.val / val2.val };
            else if (val.type === 'in' && val2.type === 'num')
              val =  { type: 'in', val: val.val / val2.val };
            else if (val.type === 'in' && val2.type === 'in')
              val =  { type: 'num', val: val.val / val2.val };
            else
              throw "Cannot divide numbers by lengths";
          } else {
            break;
          }
        }
        return val;
      }

      // Parse an (additive) expression:
      //    mulexpr + mulexpr
      //    mulexpr - mulexpr

      function parseExpr() {
        const backtrack = parsepos;
        let val = parseMulExpr();
        if (val === null)
          return null;
        while (true) {
          if (take("+")) {
            let val2 = parseMulExpr();
            if (val2 === null) {
              parsepos = backtrack;
              return null;
            }
            if (val.type === 'fn' || val2.type === 'fn')
              throw "Can't add functions";
            if (val.type === 'parse' || val2.type === 'parse')
              return { type: 'parse', op: '+', expr1: val, expr2: val2 };
            if (val.type === 'num' && val2.type === 'num')
              val = { type: 'num', val: val.val + val2.val };
            else if (val.type === 'in' && val2.type === 'in')
              val = { type: 'in', val: val.val + val2.val };
            else if (val.type === 'in' && val2.type === 'num' && val2.val === 0)
              {}   // special case for adding 0; take first val
            else if (val2.type === 'in' && val.type === 'num' && val.val === 0)
              val = val2;  // special case for adding 0; take second val
            else if (val.type === 'num')
              throw "Cannot add numbers and lengths";
            else if (val.type === 'in')
              throw new SilentError("Cannot add numbers and lengths");
          } else if (take("-")) {
            let val2 = parseMulExpr();
            if (val2 === null) {
              parsepos = backtrack;
              return null;
            }
            if (val.type === 'fn' || val2.type === 'fn')
              throw "Can't subtract functions";
            if (val.type === 'parse' || val2.type === 'parse')
              return { type: 'parse', op: '-', expr1: val, expr2: val2 };
            if (val.type === 'num' && val2.type === 'num')
              val = { type: 'num', val: val.val - val2.val };
            else if (val.type === 'in' && val2.type === 'in')
              val = { type: 'in', val: val.val - val2.val };
            else if (val.type === 'in' && val2.type === 'num' && val2.val === 0)
              {}   // special case for subtracting 0; take first val
            else if (val2.type === 'in' && val.type === 'num' && val.val === 0)
              val = { type: 'in', val: -val2.val };  // special case for subtracting 0;
            else if (val.type === 'num')
              throw "Cannot subtract numbers and lengths";
            else if (val.type === 'in')
              throw new SilentError("Cannot subtract numbers and lengths");
          } else {
            break;
          }
        }
        return val;
      }

      // Parse a statement:
      //    expr
      //    word = expr
      //    word(p, p, ...) = expr

      function parseStatement() {
        const backtrack = parsepos;
        let word = parseWord();
        if (word !== null) {
          if (take('=')) {
            let val = parseExpr();
            if (val) {
              val.sym = word;
              val.defined = true;
              return val;
            }
          }
          if (take('(')) {
            let params = [];
            let param = parseWord();
            while (param !== null) {
              params.push(param);
              if (!take(','))
                break;
              param = parseWord();
            }
            if (take(')') && take('=')) {
              const saveEnv = environment;
              try {
                environment = {};
                for (const p of params)
                  environment[p] = { type: 'parse', sym: p };
                skipSpaces();
                const exprStart = parsepos;
                let expr = parseExpr();
                environment = saveEnv;
                if (expr !== null)
                  return { type: 'fn', expr: expr, sym: word, defined: true,
                           params: params, body: parsestr.substr(exprStart) };
               }
               catch (e) {
                 environment = saveEnv;
                 throw e;
               }
             }
           }
           parsepos = backtrack;
        }
        return parseExpr();
      }

      function updateParse(updateVars) {
        clearFields();
        try {
          parsestr = document.getElementById('expr').value;
          parsepos = 0;
          environment = {};
          let val = parseStatement();
          skipSpaces();
          if (val !== null && !getc()) { // nothing left over at the end
            if (updateVars && val.defined) {
              let sym = val.sym;
              if (symbols[sym])
                throw "Cannot redefine system symbols";
              showAssignResult(val);
              delete val.defined;
              userSymbols[sym] = val;
              showUserSymbols();
            } else if (val.type === 'in') {
              showResult(val.val);
            } else if (val.type === 'num') {
              showNumberResult(val.val);
            } else if (val.type === 'fn' && !val.defined) {
              showAssignResult(val);
            }
            return;
          }
        }
        catch (e) {
          showError(e);
        }

        // Gray out the result since we can't parse correctly right now
        document.getElementById('results').style.color = '#aaaaaa';  
        document.getElementById('numberResults').style.color = '#aaaaaa';
      }

      function clearFields() {
        for (const field of ['ft', 'inch', 'num', 'times', 'div'])
          document.getElementById(field).value = "";
      }

      function showNumberResult(num) {
        document.getElementById('results').style.display = 'none';
        document.getElementById('numberResults').style.display = '';
        document.getElementById('error').style.display = 'none';
        document.getElementById('numberResults').style.color = '';

        document.getElementById('numberResultsDetail').textContent = num2str(num);
      }

      function escapeHTML(str) {
        return str
          .replace(/&/g, "&amp;")
          .replace(/</g, "&lt;")
          .replace(/>/g, "&gt;")
          .replace(/"/g, "&quot;")
          .replace(/'/g, "&#039;");
      }

      function showUserSymbols() {
        document.getElementById('symdefs');
        let str = "";
        let keys = Object.keys(userSymbols).sort();
        for (const val of keys) {
          let symStr = symString(userSymbols[val]);
          if (symStr)
            str += `<p> ${escapeHTML(symStr)} </p>`;
        }
        document.getElementById('symdefs').innerHTML = str;
      }

      function symString(val) {
        if (val.type === 'in') {
          let [ftStr, inStr, delta] = inchesToStringReps(val.val);
          return `${val.sym} = ${ftStr}${delta}`;
        }
        if (val.type === 'num') {
          return `${val.sym} = ${val.val}`;
        }
        if (val.type === 'fn') {
          return `${val.sym}(${val.params.join(", ")}) = ${val.body}`;
        }
        return undefined;
      }

      function showAssignResult(val) {
        let str = symString(val);
        if (!str)
          return;
        document.getElementById('results').style.display = 'none';
        document.getElementById('numberResults').style.display = '';
        document.getElementById('error').style.display = 'none';
        document.getElementById('numberResults').style.color = '';
        document.getElementById('numberResultsDetail').textContent = str;
      }

      function showResult(totalInches, updateExpr) {
        document.getElementById('results').style.display = '';
        document.getElementById('numberResults').style.display = 'none';
        document.getElementById('error').style.display = 'none';
        document.getElementById('results').style.color = '';

        document.getElementById('resultIn').textContent = num2str(totalInches);
        document.getElementById('resultFt').textContent = num2str(totalInches/12);

        let [ftStr, inStr, delta] = inchesToStringReps(totalInches);
        document.getElementById('resultFtDetail').textContent = ftStr + delta;
        if (updateExpr)
          document.getElementById('expr').value = ftStr + delta;

        document.getElementById('resultInDetail').textContent = inStr + delta;

        // show metric for good measure
        document.getElementById('resultMeters').textContent =
          num2str(totalInches * 0.0254);
        document.getElementById('resultMetersMetricFeet').textContent =
          num2str(totalInches * 0.025);
      }

      function inchesToStringReps(totalInches) {
        let minus = "";
        if (totalInches < 0) {
          totalInches = -totalInches;
          minus = "-";
        }

        // Recover feet and inches from from result
        // (round to nearest 1/denom)
        let denom = 32;
        let inches =  ((totalInches*denom + 0.5)|0)/denom;
        let ft = (inches/12)|0;      // "n|0" truncates to an integer
        inches = inches - ft*12;
        let frac = inches - (inches|0);
        inches = inches|0;
        let num = (frac*denom)|0;
        while (denom > 2 && num%2 === 0) {  // reduce fraction
          denom = denom/2;
          num = num/2;
        }

        // format that string
        let ftStr = minus, sp = "";
        if (ft !== 0 || (inches === 0 && num === 0)) {
          ftStr += ft + "'";
          sp = " ";
        }
        if (inches !== 0) {
          ftStr += sp + inches;
          sp = " ";
        }
        if (num !== 0)
          ftStr += `${sp}${num}/${denom}`;
        if (inches !== 0 || num !== 0)
           ftStr += '"';
        let delta = totalInches - (ft*12 + inches + num/denom);
        if (Math.abs(delta) < epsilon) {
          delta = "";
        } else {
          if (delta < 0)
            delta = ` - ${num2str(-delta)}"`;
          else
            delta = ` + ${num2str(delta)}"`;
        }
 
        // format inches
        let inStr = minus;
        sp = "";
        inches = ft*12 + inches;
        if (inches !== 0 || num === 0) {
          inStr += inches;
          sp = " ";
        }
        if (num !== 0)
          inStr += `${sp}${num}/${denom}`;
        inStr += '"';
	  return [ftStr, inStr, delta];
      }

      function showHelp(id) {
        document.getElementById(id).style.display = "block"; // inherits 'none' from "help" class
      }

      document.addEventListener("keydown", function(evt) {
        evt = evt || window.event;
        if (evt.key === "Escape" || evt.key === "Esc" || evt.keyCode === 27) {
          let elts = document.querySelectorAll('.help');
          for (let e of elts)
            e.style.display = ''; // back to inherited 'none'
        }
      });

    </script>
    <p style="transform-origin: left; transform: scale(1.5)">
      <input type="text" style="text-align: right;" oninput="updateResult()" size="4" id="ft" value="5">
      feet &nbsp;
      <input type="text" style="text-align: right;" oninput="updateResult()" size="2" id="inch" value="">
      <sup>
        <input type="text" style="text-align: right;" oninput="updateResult()" size="2" align="right" id="num" value="">
      </sup>/<sub>
        <input type="text" oninput="updateResult()" size="2" id="denom" value="8">
      </sub>
      inches &nbsp;&nbsp; times
      <input type="text" oninput="updateResult()" size="3" id="times" value="">
      &nbsp; divided by
      <input type="text" oninput="updateResult()" size="3" id="div" value="">
    </p>
    <p style="transform-origin: left; transform: scale(1.5)">
      <input type="text" oninput="updateParse()" onchange="updateParse(true)" size="60" id="expr" value="">
      <span onclick="return showHelp('exprhelp')" class="button">&nbsp; ? &nbsp;</span>
    </p>
    <div style="float: left; min-width: 40em; border: 2px solid; margin: 10px 0px; padding: 0px 10px">
      <p id="results">
        <span id="resultFt"></span> feet = <span id="resultFtDetail"></span>
        <br>
        <span id="resultIn"></span> inches = <span id="resultInDetail"></span>
        <br>
        <span id="resultMeters"></span> meters
        <br>
        <span id="resultMetersMetricFeet"></span> meters (assuming "metric feet")
      </p>
      <p id="numberResults">
        <span id="numberResultsDetail"></span>
      </p>
      <p id="error" style="color: red"></p>
    </div>
    <div style="clear: both"></div>
    <div id="symdefs"></div>
    <div style="font-size: 85%; margin-block-start: 1em;">
      <bl>
        <li>
          Fields may be left empty when not relevent
        </li>
        <li>
          A value like five and a half feet may be entered as 5.5 ft or as 5 ft 6 inches
        </li>
        <li>
          A value like six and a quarter inches may be entered as 6.25 inches or
          as 6 inches and 1/4
        </li>
        <li>
          A "metric foot" is a convention for metric designs where a foot is taken
          to be exactly 30cm instead of 30.48cm
        </li>
        <li>
          You can type a fairly general expression into the text box. Click the "?"
          button for more information.
        </li>
      </bl>
    </div>
    <div class="help" id="exprhelp">
      <span class="closebtn" onclick="this.parentElement.style.display='none';">&times;</span> 
      <div>
        <!-- it's neater without the optional closing tags -->
        <h3> Expressions </h3>
        <p> Expressions can contain numbers, units and the operators + - * and /.
            Multiplication and division are performed before addition and subtraction, and
            parenthesis can be used for grouping.
        <p> Units include:
            <code>ft</code> <code>'</code> <code>in</code> <code>"</code> 
            <code>m</code> and <code>cm</code>.
            The unit names can be used as constants as well.
        <p> As you type, the expression might be momentarily unparsable, e.g.,
            <code>3'+</code>, until you finish typing. 
            The results box will be grayed out while that happens.
        </p>
        <table>
          <colgroup>
            <col style="width: 8em">
            <col style="width: auto">
          </colgroup>
          <tr>
            <th> Example
            <th> Description
          <tr>
            <td> 5' 6"
            <td> An ordinary distance
          <tr>
            <td> 5' 6 3/8" / 3
            <td> Divide 5 feet 6 and 3/8 inches by 3
          <tr>
            <td> 5 1/2' - 8"
            <td> Subtracts lengths
          <tr>
            <td> 5.5'
            <td> You can use decimal values instead of fractions
          <tr>
            <td> 3/4"
            <td> You can use just a fraction
          <tr>
            <td> (5'6" + 7') / 2
            <td> The average of 5'6" and 7'
          <tr>
            <td> 5'10 3/8" * 3/4
            <td> 3/4 of 5' 10 3/8"
          <tr>
            <td> 12' / 6"
            <td> The ratio of 12' and 6" (result is 24)
          <tr>
            <td> 1 + 2 * 3
            <td> Ordinary math (note order of operations; result is 7)
          <tr>
            <td> 1m - 2cm
            <td> One meter minus two centimeters
         <tr>
            <td> ft
            <td> A foot
          <tr>
            <td> ft * 12
            <td> 12 feet; notice that such units are simply length-valued variables
          <tr>
            <td> 5' 6" * pi
            <td> Circumference of a 5' 6" diameter circle
          <tr>
            <td> hyp(3', 4')
            <td> Hypotenuse of a right triangle with sides 3' and 4' (result is 5')
        </table>
        <h4> Terms </h4>
        <p> Expressions are built up out of <i>terms</i> which are either
            <bl>
              <li> A plain number such as <code>12</code>, <code>3.14</code>, <code>.15,</code> etc.
              <li> A variable name, such as <code>pi</code>
              <li> A <i>length</i> which can be a number, a fraction, or a number
                   and a fraction followed buy a <i>unit</i>
              <li> Any sequence of the the previous length-unit combinations as long as
                   the units are of descending size
            </bl>
        <p> A <i>unit</i> is either <code>'</code> (feet), <code>ft</code> (feet),
            <code>"</code> (inches), <code>in</code> (inches), <code>m</code> (meters),
            or <code>cm</code> (centimeters).
            In fact, any <i>variable</i> you define as a length can be used as a unit
            (<code>ft</code>, <code>in</code>, <code>m</code>, and <code>cm</code> are simply
            predefined immutable variables).
        <p> For example, if you enter
            <code>yd = 3'</code>, you can then use expressions like <code>3yd 5 1/2"</code>.
            Potentially useful definitions besides <code>yd</code> are <code>mi = 5280'</code>
            and <code>km = 1000m</code>.
        <p> Units must be specified in descending order.
            You can use <code>12'3"</code> but you can't use <code>12"3'</code>.
            This is to prevent accidentally typing <code>12'3'</code> when you really
            meant <code>12'3"</code>.
            You can type nonsense like <code>3 1/2m 3.5"</code> if you want, but you won't
            do it by accident.
        <h3> Variables </h3>
        <p> Define variables by typing <code class="abstract">name = expression</code>
            then hitting "enter."
            For instance, <code>frontage = 45'4 3/4"</code>. You can then use those values
            in later expressions, e.g. <code>frontage/3</code>.
            Amusingly, perhaps, because <code>frontage</code> is a length, it can also be
            used as a unit:  <code>1/3 frontage</code>.
        <p>The variables <code>ft</code>, <code>in</code>, <code>m</code>, and <code>cm</code>
            are predefined for use as values or as units. The variable <code>pi</code> is
            predefined in case you care about circles. Predefined variables cannot be changed.
        <h3> Functions </h3>
        <p> Define functions by typing
            <code class="abstract">name(param,param,&hellip;) = expression</code>
            then hitting "enter." For instance, you can define a function to average to numbers
            or lengths: <code>average(x,y) = (x+y)/2</code>, but the prefefined function
            <code>mean(&hellip;)</code> already does that.
        <p> The function <code>hyp(x,y)</code> is predefined to find the hypotenuse of a
            a triangle or, more usefully, the diagonal of a rectangle.
            The function <code>mean(x,y,&hellip;)</code> is predefined to find the average of
            a set of numbers or lengths.
      </div>
    </div>
  </body>
</html>